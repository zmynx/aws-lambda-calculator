"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialPlugins = void 0;
const util_1 = require("util");
const provider_caching_1 = require("./provider-caching");
const logging_1 = require("../../logging");
const error_1 = require("../../toolkit/error");
const error_2 = require("../../util/error");
const plugin_1 = require("../plugin/plugin");
/**
 * Cache for credential providers.
 *
 * Given an account and an operating mode (read or write) will return an
 * appropriate credential provider for credentials for the given account. The
 * credential provider will be cached so that multiple AWS clients for the same
 * environment will not make multiple network calls to obtain credentials.
 *
 * Will use default credentials if they are for the right account; otherwise,
 * all loaded credential provider plugins will be tried to obtain credentials
 * for the given account.
 */
class CredentialPlugins {
    constructor(host) {
        this.cache = {};
        this.host = host ?? plugin_1.PluginHost.instance;
    }
    async fetchCredentialsFor(awsAccountId, mode) {
        const key = `${awsAccountId}-${mode}`;
        if (!(key in this.cache)) {
            this.cache[key] = await this.lookupCredentials(awsAccountId, mode);
        }
        return this.cache[key];
    }
    get availablePluginNames() {
        return this.host.credentialProviderSources.map((s) => s.name);
    }
    async lookupCredentials(awsAccountId, mode) {
        const triedSources = [];
        // Otherwise, inspect the various credential sources we have
        for (const source of this.host.credentialProviderSources) {
            let available;
            try {
                available = await source.isAvailable();
            }
            catch (e) {
                // This shouldn't happen, but let's guard against it anyway
                (0, logging_1.warning)(`Uncaught exception in ${source.name}: ${(0, error_2.formatErrorMessage)(e)}`);
                available = false;
            }
            if (!available) {
                (0, logging_1.debug)('Credentials source %s is not available, ignoring it.', source.name);
                continue;
            }
            triedSources.push(source);
            let canProvide;
            try {
                canProvide = await source.canProvideCredentials(awsAccountId);
            }
            catch (e) {
                // This shouldn't happen, but let's guard against it anyway
                (0, logging_1.warning)(`Uncaught exception in ${source.name}: ${(0, error_2.formatErrorMessage)(e)}`);
                canProvide = false;
            }
            if (!canProvide) {
                continue;
            }
            (0, logging_1.debug)(`Using ${source.name} credentials for account ${awsAccountId}`);
            return {
                credentials: await v3ProviderFromPlugin(() => source.getProvider(awsAccountId, mode, {
                    supportsV3Providers: true,
                })),
                pluginName: source.name,
            };
        }
        return undefined;
    }
}
exports.CredentialPlugins = CredentialPlugins;
/**
 * Take a function that calls the plugin, and turn it into an SDKv3-compatible credential provider.
 *
 * What we will do is the following:
 *
 * - Query the plugin and see what kind of result it gives us.
 * - If the result is self-refreshing or doesn't need refreshing, we turn it into an SDKv3 provider
 *   and return it directly.
 *   * If the underlying return value is a provider, we will make it a caching provider
 *     (because we can't know if it will cache by itself or not).
 *   * If the underlying return value is a static credential, caching isn't relevant.
 *   * If the underlying return value is V2 credentials, those have caching built-in.
 * - If the result is a static credential that expires, we will wrap it in an SDKv3 provider
 *   that will query the plugin again when the credential expires.
 */
async function v3ProviderFromPlugin(producer) {
    const initial = await producer();
    if (isV3Provider(initial)) {
        // Already a provider, make caching
        return (0, provider_caching_1.makeCachingProvider)(initial);
    }
    else if (isV3Credentials(initial) && initial.expiration === undefined) {
        // Static credentials that don't need refreshing nor caching
        return () => Promise.resolve(initial);
    }
    else if (isV3Credentials(initial) && initial.expiration !== undefined) {
        // Static credentials that do need refreshing and caching
        return refreshFromPluginProvider(initial, producer);
    }
    else if (isV2Credentials(initial)) {
        // V2 credentials that refresh and cache themselves
        return v3ProviderFromV2Credentials(initial);
    }
    else {
        throw new error_1.AuthenticationError(`Plugin returned a value that doesn't resemble AWS credentials: ${(0, util_1.inspect)(initial)}`);
    }
}
/**
 * Converts a V2 credential into a V3-compatible provider
 */
function v3ProviderFromV2Credentials(x) {
    return async () => {
        // Get will fetch or refresh as necessary
        await x.getPromise();
        return {
            accessKeyId: x.accessKeyId,
            secretAccessKey: x.secretAccessKey,
            sessionToken: x.sessionToken,
            expiration: x.expireTime ?? undefined,
        };
    };
}
function refreshFromPluginProvider(current, producer) {
    return async () => {
        (0, logging_1.info)((0, util_1.format)(current), Date.now());
        if ((0, provider_caching_1.credentialsAboutToExpire)(current)) {
            const newCreds = await producer();
            if (!isV3Credentials(newCreds)) {
                throw new error_1.AuthenticationError(`Plugin initially returned static V3 credentials but now returned something else: ${(0, util_1.inspect)(newCreds)}`);
            }
            current = newCreds;
        }
        return current;
    };
}
function isV3Provider(x) {
    return typeof x === 'function';
}
function isV2Credentials(x) {
    return !!(x && typeof x === 'object' && x.getPromise);
}
function isV3Credentials(x) {
    return !!(x && typeof x === 'object' && x.accessKeyId && !isV2Credentials(x));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlZGVudGlhbC1wbHVnaW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY3JlZGVudGlhbC1wbHVnaW5zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUF1QztBQUd2Qyx5REFBbUY7QUFDbkYsMkNBQXFEO0FBQ3JELCtDQUEwRDtBQUMxRCw0Q0FBc0Q7QUFFdEQsNkNBQThDO0FBRTlDOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsTUFBYSxpQkFBaUI7SUFJNUIsWUFBWSxJQUFpQjtRQUhaLFVBQUssR0FBZ0UsRUFBRSxDQUFDO1FBSXZGLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxJQUFJLG1CQUFVLENBQUMsUUFBUSxDQUFDO0lBQzFDLENBQUM7SUFFTSxLQUFLLENBQUMsbUJBQW1CLENBQUMsWUFBb0IsRUFBRSxJQUFVO1FBQy9ELE1BQU0sR0FBRyxHQUFHLEdBQUcsWUFBWSxJQUFJLElBQUksRUFBRSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNyRSxDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFFRCxJQUFXLG9CQUFvQjtRQUM3QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMseUJBQXlCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUVPLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxZQUFvQixFQUFFLElBQVU7UUFDOUQsTUFBTSxZQUFZLEdBQStCLEVBQUUsQ0FBQztRQUNwRCw0REFBNEQ7UUFDNUQsS0FBSyxNQUFNLE1B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UUFBUSxJQUFLLENBQWdDLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDeEYsQ0FBQztBQUVELFNBQVMsZUFBZSxDQUFDLENBQXVCO0lBQzlDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLFFBQVEsSUFBSSxDQUFDLENBQUMsV0FBVyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDaEYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluc3BlY3QsIGZvcm1hdCB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHR5cGUgeyBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2UsIEZvclJlYWRpbmcsIEZvcldyaXRpbmcsIFBsdWdpblByb3ZpZGVyUmVzdWx0LCBTREt2MkNvbXBhdGlibGVDcmVkZW50aWFscywgU0RLdjNDb21wYXRpYmxlQ3JlZGVudGlhbFByb3ZpZGVyLCBTREt2M0NvbXBhdGlibGVDcmVkZW50aWFscyB9IGZyb20gJ0Bhd3MtY2RrL2NsaS1wbHVnaW4tY29udHJhY3QnO1xuaW1wb3J0IHR5cGUgeyBBd3NDcmVkZW50aWFsSWRlbnRpdHksIEF3c0NyZWRlbnRpYWxJZGVudGl0eVByb3ZpZGVyIH0gZnJvbSAnQHNtaXRoeS90eXBlcyc7XG5pbXBvcnQgeyBjcmVkZW50aWFsc0Fib3V0VG9FeHBpcmUsIG1ha2VDYWNoaW5nUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVyLWNhY2hpbmcnO1xuaW1wb3J0IHsgZGVidWcsIHdhcm5pbmcsIGluZm8gfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IEF1dGhlbnRpY2F0aW9uRXJyb3IgfSBmcm9tICcuLi8uLi90b29sa2l0L2Vycm9yJztcbmltcG9ydCB7IGZvcm1hdEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL3V0aWwvZXJyb3InO1xuaW1wb3J0IHsgTW9kZSB9IGZyb20gJy4uL3BsdWdpbi9tb2RlJztcbmltcG9ydCB7IFBsdWdpbkhvc3QgfSBmcm9tICcuLi9wbHVnaW4vcGx1Z2luJztcblxuLyoqXG4gKiBDYWNoZSBmb3IgY3JlZGVudGlhbCBwcm92aWRlcnMuXG4gKlxuICogR2l2ZW4gYW4gYWNjb3VudCBhbmQgYW4gb3BlcmF0aW5nIG1vZGUgKHJlYWQgb3Igd3JpdGUpIHdpbGwgcmV0dXJuIGFuXG4gKiBhcHByb3ByaWF0ZSBjcmVkZW50aWFsIHByb3ZpZGVyIGZvciBjcmVkZW50aWFscyBmb3IgdGhlIGdpdmVuIGFjY291bnQuIFRoZVxuICogY3JlZGVudGlhbCBwcm92aWRlciB3aWxsIGJlIGNhY2hlZCBzbyB0aGF0IG11bHRpcGxlIEFXUyBjbGllbnRzIGZvciB0aGUgc2FtZVxuICogZW52aXJvbm1lbnQgd2lsbCBub3QgbWFrZSBtdWx0aXBsZSBuZXR3b3JrIGNhbGxzIHRvIG9idGFpbiBjcmVkZW50aWFscy5cbiAqXG4gKiBXaWxsIHVzZSBkZWZhdWx0IGNyZWRlbnRpYWxzIGlmIHRoZXkgYXJlIGZvciB0aGUgcmlnaHQgYWNjb3VudDsgb3RoZXJ3aXNlLFxuICogYWxsIGxvYWRlZCBjcmVkZW50aWFsIHByb3ZpZGVyIHBsdWdpbnMgd2lsbCBiZSB0cmllZCB0byBvYnRhaW4gY3JlZGVudGlhbHNcbiAqIGZvciB0aGUgZ2l2ZW4gYWNjb3VudC5cbiAqL1xuZXhwb3J0IGNsYXNzIENyZWRlbnRpYWxQbHVnaW5zIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjYWNoZTogeyBba2V5OiBzdHJpbmddOiBQbHVnaW5DcmVkZW50aWFsc0ZldGNoUmVzdWx0IHwgdW5kZWZpbmVkIH0gPSB7fTtcbiAgcHJpdmF0ZSByZWFkb25seSBob3N0OiBQbHVnaW5Ib3N0O1xuXG4gIGNvbnN0cnVjdG9yKGhvc3Q/OiBQbHVnaW5Ib3N0KSB7XG4gICAgdGhpcy5ob3N0ID0gaG9zdCA/PyBQbHVnaW5Ib3N0Lmluc3RhbmNlO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGZldGNoQ3JlZGVudGlhbHNGb3IoYXdzQWNjb3VudElkOiBzdHJpbmcsIG1vZGU6IE1vZGUpOiBQcm9taXNlPFBsdWdpbkNyZWRlbnRpYWxzRmV0Y2hSZXN1bHQgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBrZXkgPSBgJHthd3NBY2NvdW50SWR9LSR7bW9kZX1gO1xuICAgIGlmICghKGtleSBpbiB0aGlzLmNhY2hlKSkge1xuICAgICAgdGhpcy5jYWNoZVtrZXldID0gYXdhaXQgdGhpcy5sb29rdXBDcmVkZW50aWFscyhhd3NBY2NvdW50SWQsIG1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZVtrZXldO1xuICB9XG5cbiAgcHVibGljIGdldCBhdmFpbGFibGVQbHVnaW5OYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaG9zdC5jcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VzLm1hcCgocykgPT4gcy5uYW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9va3VwQ3JlZGVudGlhbHMoYXdzQWNjb3VudElkOiBzdHJpbmcsIG1vZGU6IE1vZGUpOiBQcm9taXNlPFBsdWdpbkNyZWRlbnRpYWxzRmV0Y2hSZXN1bHQgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCB0cmllZFNvdXJjZXM6IENyZWRlbnRpYWxQcm92aWRlclNvdXJjZVtdID0gW107XG4gICAgLy8gT3RoZXJ3aXNlLCBpbnNwZWN0IHRoZSB2YXJpb3VzIGNyZWRlbnRpYWwgc291cmNlcyB3ZSBoYXZlXG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2YgdGhpcy5ob3N0LmNyZWRlbnRpYWxQcm92aWRlclNvdXJjZXMpIHtcbiAgICAgIGxldCBhdmFpbGFibGU6IGJvb2xlYW47XG4gICAgICB0cnkge1xuICAgICAgICBhdmFpbGFibGUgPSBhd2FpdCBzb3VyY2UuaXNBdmFpbGFibGUoKTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4sIGJ1dCBsZXQncyBndWFyZCBhZ2FpbnN0IGl0IGFueXdheVxuICAgICAgICB3YXJuaW5nKGBVbmNhdWdodCBleGNlcHRpb24gaW4gJHtzb3VyY2UubmFtZX06ICR7Zm9ybWF0RXJyb3JNZXNzYWdlKGUpfWApO1xuICAgICAgICBhdmFpbGFibGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdmFpbGFibGUpIHtcbiAgICAgICAgZGVidWcoJ0NyZWRlbnRpYWxzIHNvdXJjZSAlcyBpcyBub3QgYXZhaWxhYmxlLCBpZ25vcmluZyBpdC4nLCBzb3VyY2UubmFtZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdHJpZWRTb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICAgIGxldCBjYW5Qcm92aWRlOiBib29sZWFuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FuUHJvdmlkZSA9IGF3YWl0IHNvdXJjZS5jYW5Qcm92aWRlQ3JlZGVudGlhbHMoYXdzQWNjb3VudElkKTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4sIGJ1dCBsZXQncyBndWFyZCBhZ2FpbnN0IGl0IGFueXdheVxuICAgICAgICB3YXJuaW5nKGBVbmNhdWdodCBleGNlcHRpb24gaW4gJHtzb3VyY2UubmFtZX06ICR7Zm9ybWF0RXJyb3JNZXNzYWdlKGUpfWApO1xuICAgICAgICBjYW5Qcm92aWRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIWNhblByb3ZpZGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBkZWJ1ZyhgVXNpbmcgJHtzb3VyY2UubmFtZX0gY3JlZGVudGlhbHMgZm9yIGFjY291bnQgJHthd3NBY2NvdW50SWR9YCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNyZWRlbnRpYWxzOiBhd2FpdCB2M1Byb3ZpZGVyRnJvbVBsdWdpbigoKSA9PiBzb3VyY2UuZ2V0UHJvdmlkZXIoYXdzQWNjb3VudElkLCBtb2RlIGFzIEZvclJlYWRpbmcgfCBGb3JXcml0aW5nLCB7XG4gICAgICAgICAgc3VwcG9ydHNWM1Byb3ZpZGVyczogdHJ1ZSxcbiAgICAgICAgfSkpLFxuICAgICAgICBwbHVnaW5OYW1lOiBzb3VyY2UubmFtZSxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXN1bHQgZnJvbSB0cnlpbmcgdG8gZmV0Y2ggY3JlZGVudGlhbHMgZnJvbSB0aGUgUGx1Z2luIGhvc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQbHVnaW5DcmVkZW50aWFsc0ZldGNoUmVzdWx0IHtcbiAgLyoqXG4gICAqIFNESy12MyBjb21wYXRpYmxlIGNyZWRlbnRpYWwgcHJvdmlkZXJcbiAgICovXG4gIHJlYWRvbmx5IGNyZWRlbnRpYWxzOiBBd3NDcmVkZW50aWFsSWRlbnRpdHlQcm92aWRlcjtcblxuICAvKipcbiAgICogTmFtZSBvZiBwbHVnaW4gdGhhdCBzdWNjZXNzZnVsbHkgcHJvdmlkZWQgY3JlZGVudGlhbHNcbiAgICovXG4gIHJlYWRvbmx5IHBsdWdpbk5hbWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBUYWtlIGEgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgcGx1Z2luLCBhbmQgdHVybiBpdCBpbnRvIGFuIFNES3YzLWNvbXBhdGlibGUgY3JlZGVudGlhbCBwcm92aWRlci5cbiAqXG4gKiBXaGF0IHdlIHdpbGwgZG8gaXMgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIFF1ZXJ5IHRoZSBwbHVnaW4gYW5kIHNlZSB3aGF0IGtpbmQgb2YgcmVzdWx0IGl0IGdpdmVzIHVzLlxuICogLSBJZiB0aGUgcmVzdWx0IGlzIHNlbGYtcmVmcmVzaGluZyBvciBkb2Vzbid0IG5lZWQgcmVmcmVzaGluZywgd2UgdHVybiBpdCBpbnRvIGFuIFNES3YzIHByb3ZpZGVyXG4gKiAgIGFuZCByZXR1cm4gaXQgZGlyZWN0bHkuXG4gKiAgICogSWYgdGhlIHVuZGVybHlpbmcgcmV0dXJuIHZhbHVlIGlzIGEgcHJvdmlkZXIsIHdlIHdpbGwgbWFrZSBpdCBhIGNhY2hpbmcgcHJvdmlkZXJcbiAqICAgICAoYmVjYXVzZSB3ZSBjYW4ndCBrbm93IGlmIGl0IHdpbGwgY2FjaGUgYnkgaXRzZWxmIG9yIG5vdCkuXG4gKiAgICogSWYgdGhlIHVuZGVybHlpbmcgcmV0dXJuIHZhbHVlIGlzIGEgc3RhdGljIGNyZWRlbnRpYWwsIGNhY2hpbmcgaXNuJ3QgcmVsZXZhbnQuXG4gKiAgICogSWYgdGhlIHVuZGVybHlpbmcgcmV0dXJuIHZhbHVlIGlzIFYyIGNyZWRlbnRpYWxzLCB0aG9zZSBoYXZlIGNhY2hpbmcgYnVpbHQtaW4uXG4gKiAtIElmIHRoZSByZXN1bHQgaXMgYSBzdGF0aWMgY3JlZGVudGlhbCB0aGF0IGV4cGlyZXMsIHdlIHdpbGwgd3JhcCBpdCBpbiBhbiBTREt2MyBwcm92aWRlclxuICogICB0aGF0IHdpbGwgcXVlcnkgdGhlIHBsdWdpbiBhZ2FpbiB3aGVuIHRoZSBjcmVkZW50aWFsIGV4cGlyZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHYzUHJvdmlkZXJGcm9tUGx1Z2luKHByb2R1Y2VyOiAoKSA9PiBQcm9taXNlPFBsdWdpblByb3ZpZGVyUmVzdWx0Pik6IFByb21pc2U8QXdzQ3JlZGVudGlhbElkZW50aXR5UHJvdmlkZXI+IHtcbiAgY29uc3QgaW5pdGlhbCA9IGF3YWl0IHByb2R1Y2VyKCk7XG5cbiAgaWYgKGlzVjNQcm92aWRlcihpbml0aWFsKSkge1xuICAgIC8vIEFscmVhZHkgYSBwcm92aWRlciwgbWFrZSBjYWNoaW5nXG4gICAgcmV0dXJuIG1ha2VDYWNoaW5nUHJvdmlkZXIoaW5pdGlhbCk7XG4gIH0gZWxzZSBpZiAoaXNWM0NyZWRlbnRpYWxzKGluaXRpYWwpICYmIGluaXRpYWwuZXhwaXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gU3RhdGljIGNyZWRlbnRpYWxzIHRoYXQgZG9uJ3QgbmVlZCByZWZyZXNoaW5nIG5vciBjYWNoaW5nXG4gICAgcmV0dXJuICgpID0+IFByb21pc2UucmVzb2x2ZShpbml0aWFsKTtcbiAgfSBlbHNlIGlmIChpc1YzQ3JlZGVudGlhbHMoaW5pdGlhbCkgJiYgaW5pdGlhbC5leHBpcmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBTdGF0aWMgY3JlZGVudGlhbHMgdGhhdCBkbyBuZWVkIHJlZnJlc2hpbmcgYW5kIGNhY2hpbmdcbiAgICByZXR1cm4gcmVmcmVzaEZyb21QbHVnaW5Qcm92aWRlcihpbml0aWFsLCBwcm9kdWNlcik7XG4gIH0gZWxzZSBpZiAoaXNWMkNyZWRlbnRpYWxzKGluaXRpYWwpKSB7XG4gICAgLy8gVjIgY3JlZGVudGlhbHMgdGhhdCByZWZyZXNoIGFuZCBjYWNoZSB0aGVtc2VsdmVzXG4gICAgcmV0dXJuIHYzUHJvdmlkZXJGcm9tVjJDcmVkZW50aWFscyhpbml0aWFsKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihgUGx1Z2luIHJldHVybmVkIGEgdmFsdWUgdGhhdCBkb2Vzbid0IHJlc2VtYmxlIEFXUyBjcmVkZW50aWFsczogJHtpbnNwZWN0KGluaXRpYWwpfWApO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBWMiBjcmVkZW50aWFsIGludG8gYSBWMy1jb21wYXRpYmxlIHByb3ZpZGVyXG4gKi9cbmZ1bmN0aW9uIHYzUHJvdmlkZXJGcm9tVjJDcmVkZW50aWFscyh4OiBTREt2MkNvbXBhdGlibGVDcmVkZW50aWFscyk6IEF3c0NyZWRlbnRpYWxJZGVudGl0eVByb3ZpZGVyIHtcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAvLyBHZXQgd2lsbCBmZXRjaCBvciByZWZyZXNoIGFzIG5lY2Vzc2FyeVxuICAgIGF3YWl0IHguZ2V0UHJvbWlzZSgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY2Vzc0tleUlkOiB4LmFjY2Vzc0tleUlkLFxuICAgICAgc2VjcmV0QWNjZXNzS2V5OiB4LnNlY3JldEFjY2Vzc0tleSxcbiAgICAgIHNlc3Npb25Ub2tlbjogeC5zZXNzaW9uVG9rZW4sXG4gICAgICBleHBpcmF0aW9uOiB4LmV4cGlyZVRpbWUgPz8gdW5kZWZpbmVkLFxuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlZnJlc2hGcm9tUGx1Z2luUHJvdmlkZXIoY3VycmVudDogQXdzQ3JlZGVudGlhbElkZW50aXR5LCBwcm9kdWNlcjogKCkgPT4gUHJvbWlzZTxQbHVnaW5Qcm92aWRlclJlc3VsdD4pOiBBd3NDcmVkZW50aWFsSWRlbnRpdHlQcm92aWRlciB7XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgaW5mbyhmb3JtYXQoY3VycmVudCksIERhdGUubm93KCkpO1xuICAgIGlmIChjcmVkZW50aWFsc0Fib3V0VG9FeHBpcmUoY3VycmVudCkpIHtcbiAgICAgIGNvbnN0IG5ld0NyZWRzID0gYXdhaXQgcHJvZHVjZXIoKTtcbiAgICAgIGlmICghaXNWM0NyZWRlbnRpYWxzKG5ld0NyZWRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihgUGx1Z2luIGluaXRpYWxseSByZXR1cm5lZCBzdGF0aWMgVjMgY3JlZGVudGlhbHMgYnV0IG5vdyByZXR1cm5lZCBzb21ldGhpbmcgZWxzZTogJHtpbnNwZWN0KG5ld0NyZWRzKX1gKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBuZXdDcmVkcztcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzVjNQcm92aWRlcih4OiBQbHVnaW5Qcm92aWRlclJlc3VsdCk6IHggaXMgU0RLdjNDb21wYXRpYmxlQ3JlZGVudGlhbFByb3ZpZGVyIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc1YyQ3JlZGVudGlhbHMoeDogUGx1Z2luUHJvdmlkZXJSZXN1bHQpOiB4IGlzIFNES3YyQ29tcGF0aWJsZUNyZWRlbnRpYWxzIHtcbiAgcmV0dXJuICEhKHggJiYgdHlwZW9mIHggPT09ICdvYmplY3QnICYmICh4IGFzIFNES3YyQ29tcGF0aWJsZUNyZWRlbnRpYWxzKS5nZXRQcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gaXNWM0NyZWRlbnRpYWxzKHg6IFBsdWdpblByb3ZpZGVyUmVzdWx0KTogeCBpcyBTREt2M0NvbXBhdGlibGVDcmVkZW50aWFscyB7XG4gIHJldHVybiAhISh4ICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4LmFjY2Vzc0tleUlkICYmICFpc1YyQ3JlZGVudGlhbHMoeCkpO1xufVxuIl19