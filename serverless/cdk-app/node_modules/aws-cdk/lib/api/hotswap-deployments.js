"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryHotswapDeployment = tryHotswapDeployment;
const cfn_diff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const evaluate_cloudformation_template_1 = require("./evaluate-cloudformation-template");
const logging_1 = require("../logging");
const appsync_mapping_templates_1 = require("./hotswap/appsync-mapping-templates");
const code_build_projects_1 = require("./hotswap/code-build-projects");
const common_1 = require("./hotswap/common");
const ecs_services_1 = require("./hotswap/ecs-services");
const lambda_functions_1 = require("./hotswap/lambda-functions");
const s3_bucket_deployments_1 = require("./hotswap/s3-bucket-deployments");
const stepfunctions_state_machines_1 = require("./hotswap/stepfunctions-state-machines");
const nested_stack_helpers_1 = require("./nested-stack-helpers");
const mode_1 = require("./plugin/mode");
const error_1 = require("../util/error");
// Must use a require() otherwise esbuild complains about calling a namespace
// eslint-disable-next-line @typescript-eslint/no-require-imports
const pLimit = require('p-limit');
const RESOURCE_DETECTORS = {
    // Lambda
    'AWS::Lambda::Function': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Version': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Alias': lambda_functions_1.isHotswappableLambdaFunctionChange,
    // AppSync
    'AWS::AppSync::Resolver': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::FunctionConfiguration': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::GraphQLSchema': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::ApiKey': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::ECS::TaskDefinition': ecs_services_1.isHotswappableEcsServiceChange,
    'AWS::CodeBuild::Project': code_build_projects_1.isHotswappableCodeBuildProjectChange,
    'AWS::StepFunctions::StateMachine': stepfunctions_state_machines_1.isHotswappableStateMachineChange,
    'Custom::CDKBucketDeployment': s3_bucket_deployments_1.isHotswappableS3BucketDeploymentChange,
    'AWS::IAM::Policy': async (logicalId, change, evaluateCfnTemplate) => {
        // If the policy is for a S3BucketDeploymentChange, we can ignore the change
        if (await (0, s3_bucket_deployments_1.skipChangeForS3DeployCustomResourcePolicy)(logicalId, change, evaluateCfnTemplate)) {
            return [];
        }
        return (0, common_1.reportNonHotswappableResource)(change, 'This resource type is not supported for hotswap deployments');
    },
    'AWS::CDK::Metadata': async () => [],
};
/**
 * Perform a hotswap deployment, short-circuiting CloudFormation if possible.
 * If it's not possible to short-circuit the deployment
 * (because the CDK Stack contains changes that cannot be deployed without CloudFormation),
 * returns `undefined`.
 */
async function tryHotswapDeployment(sdkProvider, assetParams, cloudFormationStack, stackArtifact, hotswapMode, hotswapPropertyOverrides) {
    // resolve the environment, so we can substitute things like AWS::Region in CFN expressions
    const resolvedEnv = await sdkProvider.resolveEnvironment(stackArtifact.environment);
    // create a new SDK using the CLI credentials, because the default one will not work for new-style synthesis -
    // it assumes the bootstrap deploy Role, which doesn't have permissions to update Lambda functions
    const sdk = (await sdkProvider.forEnvironment(resolvedEnv, mode_1.Mode.ForWriting)).sdk;
    const currentTemplate = await (0, nested_stack_helpers_1.loadCurrentTemplateWithNestedStacks)(stackArtifact, sdk);
    const evaluateCfnTemplate = new evaluate_cloudformation_template_1.EvaluateCloudFormationTemplate({
        stackName: stackArtifact.stackName,
        template: stackArtifact.template,
        parameters: assetParams,
        account: resolvedEnv.account,
        region: resolvedEnv.region,
        partition: (await sdk.currentAccount()).partition,
        sdk,
        nestedStacks: currentTemplate.nestedStacks,
    });
    const stackChanges = cfn_diff.fullDiff(currentTemplate.deployedRootTemplate, stackArtifact.template);
    const { hotswappableChanges, nonHotswappableChanges } = await classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, currentTemplate.nestedStacks, hotswapPropertyOverrides);
    logNonHotswappableChanges(nonHotswappableChanges, hotswapMode);
    // preserve classic hotswap behavior
    if (hotswapMode === common_1.HotswapMode.FALL_BACK) {
        if (nonHotswappableChanges.length > 0) {
            return undefined;
        }
    }
    // apply the short-circuitable changes
    await applyAllHotswappableChanges(sdk, hotswappableChanges);
    return {
        type: 'did-deploy-stack',
        noOp: hotswappableChanges.length === 0,
        stackArn: cloudFormationStack.stackId,
        outputs: cloudFormationStack.outputs,
    };
}
/**
 * Classifies all changes to all resources as either hotswappable or not.
 * Metadata changes are excluded from the list of (non)hotswappable resources.
 */
async function classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, nestedStackNames, hotswapPropertyOverrides) {
    const resourceDifferences = getStackResourceDifferences(stackChanges);
    const promises = [];
    const hotswappableResources = new Array();
    const nonHotswappableResources = new Array();
    for (const logicalId of Object.keys(stackChanges.outputs.changes)) {
        nonHotswappableResources.push({
            hotswappable: false,
            reason: 'output was changed',
            logicalId,
            rejectedChanges: [],
            resourceType: 'Stack Output',
        });
    }
    // gather the results of the detector functions
    for (const [logicalId, change] of Object.entries(resourceDifferences)) {
        if (change.newValue?.Type === 'AWS::CloudFormation::Stack' && change.oldValue?.Type === 'AWS::CloudFormation::Stack') {
            const nestedHotswappableResources = await findNestedHotswappableChanges(logicalId, change, nestedStackNames, evaluateCfnTemplate, sdk, hotswapPropertyOverrides);
            hotswappableResources.push(...nestedHotswappableResources.hotswappableChanges);
            nonHotswappableResources.push(...nestedHotswappableResources.nonHotswappableChanges);
            continue;
        }
        const hotswappableChangeCandidate = isCandidateForHotswapping(change, logicalId);
        // we don't need to run this through the detector functions, we can already judge this
        if ('hotswappable' in hotswappableChangeCandidate) {
            if (!hotswappableChangeCandidate.hotswappable) {
                nonHotswappableResources.push(hotswappableChangeCandidate);
            }
            continue;
        }
        const resourceType = hotswappableChangeCandidate.newValue.Type;
        if (resourceType in RESOURCE_DETECTORS) {
            // run detector functions lazily to prevent unhandled promise rejections
            promises.push(() => RESOURCE_DETECTORS[resourceType](logicalId, hotswappableChangeCandidate, evaluateCfnTemplate, hotswapPropertyOverrides));
        }
        else {
            (0, common_1.reportNonHotswappableChange)(nonHotswappableResources, hotswappableChangeCandidate, undefined, 'This resource type is not supported for hotswap deployments');
        }
    }
    // resolve all detector results
    const changesDetectionResults = [];
    for (const detectorResultPromises of promises) {
        // Constant set of promises per resource
        // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
        const hotswapDetectionResults = await Promise.all(await detectorResultPromises());
        changesDetectionResults.push(hotswapDetectionResults);
    }
    for (const resourceDetectionResults of changesDetectionResults) {
        for (const propertyResult of resourceDetectionResults) {
            propertyResult.hotswappable
                ? hotswappableResources.push(propertyResult)
                : nonHotswappableResources.push(propertyResult);
        }
    }
    return {
        hotswappableChanges: hotswappableResources,
        nonHotswappableChanges: nonHotswappableResources,
    };
}
/**
 * Returns all changes to resources in the given Stack.
 *
 * @param stackChanges the collection of all changes to a given Stack
 */
function getStackResourceDifferences(stackChanges) {
    // we need to collapse logical ID rename changes into one change,
    // as they are represented in stackChanges as a pair of two changes: one addition and one removal
    const allResourceChanges = stackChanges.resources.changes;
    const allRemovalChanges = filterDict(allResourceChanges, (resChange) => resChange.isRemoval);
    const allNonRemovalChanges = filterDict(allResourceChanges, (resChange) => !resChange.isRemoval);
    for (const [logId, nonRemovalChange] of Object.entries(allNonRemovalChanges)) {
        if (nonRemovalChange.isAddition) {
            const addChange = nonRemovalChange;
            // search for an identical removal change
            const identicalRemovalChange = Object.entries(allRemovalChanges).find(([_, remChange]) => {
                return changesAreForSameResource(remChange, addChange);
            });
            // if we found one, then this means this is a rename change
            if (identicalRemovalChange) {
                const [removedLogId, removedResourceChange] = identicalRemovalChange;
                allNonRemovalChanges[logId] = makeRenameDifference(removedResourceChange, addChange);
                // delete the removal change that forms the rename pair
                delete allRemovalChanges[removedLogId];
            }
        }
    }
    // the final result are all of the remaining removal changes,
    // plus all of the non-removal changes
    // (we saved the rename changes in that object already)
    return {
        ...allRemovalChanges,
        ...allNonRemovalChanges,
    };
}
/** Filters an object with string keys based on whether the callback returns 'true' for the given value in the object. */
function filterDict(dict, func) {
    return Object.entries(dict).reduce((acc, [key, t]) => {
        if (func(t)) {
            acc[key] = t;
        }
        return acc;
    }, {});
}
/** Finds any hotswappable changes in all nested stacks. */
async function findNestedHotswappableChanges(logicalId, change, nestedStackTemplates, evaluateCfnTemplate, sdk, hotswapPropertyOverrides) {
    const nestedStack = nestedStackTemplates[logicalId];
    if (!nestedStack.physicalName) {
        return {
            hotswappableChanges: [],
            nonHotswappableChanges: [
                {
                    hotswappable: false,
                    logicalId,
                    reason: `physical name for AWS::CloudFormation::Stack '${logicalId}' could not be found in CloudFormation, so this is a newly created nested stack and cannot be hotswapped`,
                    rejectedChanges: [],
                    resourceType: 'AWS::CloudFormation::Stack',
                },
            ],
        };
    }
    const evaluateNestedCfnTemplate = await evaluateCfnTemplate.createNestedEvaluateCloudFormationTemplate(nestedStack.physicalName, nestedStack.generatedTemplate, change.newValue?.Properties?.Parameters);
    const nestedDiff = cfn_diff.fullDiff(nestedStackTemplates[logicalId].deployedTemplate, nestedStackTemplates[logicalId].generatedTemplate);
    return classifyResourceChanges(nestedDiff, evaluateNestedCfnTemplate, sdk, nestedStackTemplates[logicalId].nestedStackTemplates, hotswapPropertyOverrides);
}
/** Returns 'true' if a pair of changes is for the same resource. */
function changesAreForSameResource(oldChange, newChange) {
    return (oldChange.oldResourceType === newChange.newResourceType &&
        // this isn't great, but I don't want to bring in something like underscore just for this comparison
        JSON.stringify(oldChange.oldProperties) === JSON.stringify(newChange.newProperties));
}
function makeRenameDifference(remChange, addChange) {
    return new cfn_diff.ResourceDifference(
    // we have to fill in the old value, because otherwise this will be classified as a non-hotswappable change
    remChange.oldValue, addChange.newValue, {
        resourceType: {
            oldType: remChange.oldResourceType,
            newType: addChange.newResourceType,
        },
        propertyDiffs: addChange.propertyDiffs,
        otherDiffs: addChange.otherDiffs,
    });
}
/**
 * Returns a `HotswappableChangeCandidate` if the change is hotswappable
 * Returns an empty `HotswappableChange` if the change is to CDK::Metadata
 * Returns a `NonHotswappableChange` if the change is not hotswappable
 */
function isCandidateForHotswapping(change, logicalId) {
    // a resource has been removed OR a resource has been added; we can't short-circuit that change
    if (!change.oldValue) {
        return {
            hotswappable: false,
            resourceType: change.newValue.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' was created by this deployment`,
        };
    }
    else if (!change.newValue) {
        return {
            hotswappable: false,
            resourceType: change.oldValue.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' was destroyed by this deployment`,
        };
    }
    // a resource has had its type changed
    if (change.newValue?.Type !== change.oldValue?.Type) {
        return {
            hotswappable: false,
            resourceType: change.newValue?.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' had its type changed from '${change.oldValue?.Type}' to '${change.newValue?.Type}'`,
        };
    }
    return {
        logicalId,
        oldValue: change.oldValue,
        newValue: change.newValue,
        propertyUpdates: change.propertyUpdates,
    };
}
async function applyAllHotswappableChanges(sdk, hotswappableChanges) {
    if (hotswappableChanges.length > 0) {
        (0, logging_1.info)(`\n${common_1.ICON} hotswapping resources:`);
    }
    const limit = pLimit(10);
    // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
    return Promise.all(hotswappableChanges.map(hotswapOperation => limit(() => {
        return applyHotswappableChange(sdk, hotswapOperation);
    })));
}
async function applyHotswappableChange(sdk, hotswapOperation) {
    // note the type of service that was successfully hotswapped in the User-Agent
    const customUserAgent = `cdk-hotswap/success-${hotswapOperation.service}`;
    sdk.appendCustomUserAgent(customUserAgent);
    for (const name of hotswapOperation.resourceNames) {
        (0, logging_1.info)(`   ${common_1.ICON} %s`, chalk.bold(name));
    }
    // if the SDK call fails, an error will be thrown by the SDK
    // and will prevent the green 'hotswapped!' text from being displayed
    try {
        await hotswapOperation.apply(sdk);
    }
    catch (e) {
        if (e.name === 'TimeoutError' || e.name === 'AbortError') {
            const result = JSON.parse((0, error_1.formatErrorMessage)(e));
            const error = new Error([
                `Resource is not in the expected state due to waiter status: ${result.state}`,
                result.reason ? `${result.reason}.` : '',
            ].join('. '));
            error.name = e.name;
            throw error;
        }
        throw e;
    }
    for (const name of hotswapOperation.resourceNames) {
        (0, logging_1.info)(`${common_1.ICON} %s %s`, chalk.bold(name), chalk.green('hotswapped!'));
    }
    sdk.removeCustomUserAgent(customUserAgent);
}
function logNonHotswappableChanges(nonHotswappableChanges, hotswapMode) {
    if (nonHotswappableChanges.length === 0) {
        return;
    }
    /**
     * EKS Services can have a task definition that doesn't refer to the task definition being updated.
     * We have to log this as a non-hotswappable change to the task definition, but when we do,
     * we wind up hotswapping the task definition and logging it as a non-hotswappable change.
     *
     * This logic prevents us from logging that change as non-hotswappable when we hotswap it.
     */
    if (hotswapMode === common_1.HotswapMode.HOTSWAP_ONLY) {
        nonHotswappableChanges = nonHotswappableChanges.filter((change) => change.hotswapOnlyVisible === true);
        if (nonHotswappableChanges.length === 0) {
            return;
        }
    }
    if (hotswapMode === common_1.HotswapMode.HOTSWAP_ONLY) {
        (0, logging_1.info)('\n%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found. To reconcile these using CloudFormation, specify --hotswap-fallback'));
    }
    else {
        (0, logging_1.info)('\n%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found:'));
    }
    for (const change of nonHotswappableChanges) {
        change.rejectedChanges.length > 0
            ? (0, logging_1.info)('    logicalID: %s, type: %s, rejected changes: %s, reason: %s', chalk.bold(change.logicalId), chalk.bold(change.resourceType), chalk.bold(change.rejectedChanges), chalk.red(change.reason))
            : (0, logging_1.info)('    logicalID: %s, type: %s, reason: %s', chalk.bold(change.logicalId), chalk.bold(change.resourceType), chalk.red(change.reason));
    }
    (0, logging_1.info)(''); // newline
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG90c3dhcC1kZXBsb3ltZW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhvdHN3YXAtZGVwbG95bWVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFrRkEsb0RBb0RDO0FBdElELHlEQUF5RDtBQUd6RCwrQkFBK0I7QUFHL0IseUZBQW9GO0FBQ3BGLHdDQUFrQztBQUNsQyxtRkFBa0Y7QUFDbEYsdUVBQXFGO0FBQ3JGLDZDQVUwQjtBQUMxQix5REFBd0U7QUFDeEUsaUVBQWdGO0FBQ2hGLDJFQUd5QztBQUN6Qyx5RkFBMEY7QUFDMUYsaUVBQW1HO0FBQ25HLHdDQUFxQztBQUVyQyx5Q0FBbUQ7QUFFbkQsNkVBQTZFO0FBQzdFLGlFQUFpRTtBQUNqRSxNQUFNLE1BQU0sR0FBNkIsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBUzVELE1BQU0sa0JBQWtCLEdBQXVDO0lBQzdELFNBQVM7SUFDVCx1QkFBdUIsRUFBRSxxREFBa0M7SUFDM0Qsc0JBQXNCLEVBQUUscURBQWtDO0lBQzFELG9CQUFvQixFQUFFLHFEQUFrQztJQUV4RCxVQUFVO0lBQ1Ysd0JBQXdCLEVBQUUsdURBQTJCO0lBQ3JELHFDQUFxQyxFQUFFLHVEQUEyQjtJQUNsRSw2QkFBNkIsRUFBRSx1REFBMkI7SUFDMUQsc0JBQXNCLEVBQUUsdURBQTJCO0lBRW5ELDBCQUEwQixFQUFFLDZDQUE4QjtJQUMxRCx5QkFBeUIsRUFBRSwwREFBb0M7SUFDL0Qsa0NBQWtDLEVBQUUsK0RBQWdDO0lBQ3BFLDZCQUE2QixFQUFFLDhEQUFzQztJQUNyRSxrQkFBa0IsRUFBRSxLQUFLLEVBQ3ZCLFNBQWlCLEVBQ2pCLE1BQW1DLEVBQ25DLG1CQUFtRCxFQUNyQixFQUFFO1FBQ2hDLDRFQUE0RTtRQUM1RSxJQUFJLE1BQU0sSUFBQSxpRUFBeUMsRUFBQyxTQUFTLEVBQUUsTUFBTSxFQUFFLG1CQUFtQixDQUFDLEVBQUUsQ0FBQztZQUM1RixPQUFPLEVBQUUsQ0FBQztRQUNaLENBQUM7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QUFZLEVBQUUsQ0FBQztRQUM3QyxJQUFBLGNBQUksRUFDRixTQUFTLEVBQ1QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFDZixLQUFLLENBQUMsR0FBRyxDQUNQLHdIQUF3SCxDQUN6SCxDQUNGLENBQUM7SUFDSixDQUFDO1NBQU0sQ0FBQztRQUNOLElBQUEsY0FBSSxFQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsb0RBQW9ELENBQUMsQ0FBQyxDQUFDO0lBQ3BHLENBQUM7SUFFRCxLQUFLLE1BQU0sTUFBTSxJQUFJLHNCQUFzQixFQUFFLENBQUM7UUFDNUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQztZQUMvQixDQUFDLENBQUMsSUFBQSxjQUFJLEVBQ0osK0RBQStELEVBQy9ELEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUM1QixLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFDL0IsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLEVBQ2xDLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUN6QjtZQUNELENBQUMsQ0FBQyxJQUFBLGNBQUksRUFDSix5Q0FBeUMsRUFDekMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQzVCLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxFQUMvQixLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FDekIsQ0FBQztJQUNOLENBQUM7SUFFRCxJQUFBLGNBQUksRUFBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVU7QUFDdEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNmbl9kaWZmIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IFdhaXRlclJlc3VsdCB9IGZyb20gJ0BzbWl0aHkvdXRpbC13YWl0ZXInO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0IHR5cGUgeyBTREssIFNka1Byb3ZpZGVyIH0gZnJvbSAnLi9hd3MtYXV0aCc7XG5pbXBvcnQgdHlwZSB7IFN1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdCB9IGZyb20gJy4vZGVwbG95LXN0YWNrJztcbmltcG9ydCB7IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB9IGZyb20gJy4vZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUnO1xuaW1wb3J0IHsgaW5mbyB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVBcHBTeW5jQ2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL2FwcHN5bmMtbWFwcGluZy10ZW1wbGF0ZXMnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVDb2RlQnVpbGRQcm9qZWN0Q2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL2NvZGUtYnVpbGQtcHJvamVjdHMnO1xuaW1wb3J0IHtcbiAgSUNPTixcbiAgQ2hhbmdlSG90c3dhcFJlc3VsdCxcbiAgSG90c3dhcE1vZGUsXG4gIEhvdHN3YXBwYWJsZUNoYW5nZSxcbiAgTm9uSG90c3dhcHBhYmxlQ2hhbmdlLFxuICBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4gIEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcywgQ2xhc3NpZmllZFJlc291cmNlQ2hhbmdlcyxcbiAgcmVwb3J0Tm9uSG90c3dhcHBhYmxlQ2hhbmdlLFxuICByZXBvcnROb25Ib3Rzd2FwcGFibGVSZXNvdXJjZSxcbn0gZnJvbSAnLi9ob3Rzd2FwL2NvbW1vbic7XG5pbXBvcnQgeyBpc0hvdHN3YXBwYWJsZUVjc1NlcnZpY2VDaGFuZ2UgfSBmcm9tICcuL2hvdHN3YXAvZWNzLXNlcnZpY2VzJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlTGFtYmRhRnVuY3Rpb25DaGFuZ2UgfSBmcm9tICcuL2hvdHN3YXAvbGFtYmRhLWZ1bmN0aW9ucyc7XG5pbXBvcnQge1xuICBza2lwQ2hhbmdlRm9yUzNEZXBsb3lDdXN0b21SZXNvdXJjZVBvbGljeSxcbiAgaXNIb3Rzd2FwcGFibGVTM0J1Y2tldERlcGxveW1lbnRDaGFuZ2UsXG59IGZyb20gJy4vaG90c3dhcC9zMy1idWNrZXQtZGVwbG95bWVudHMnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVTdGF0ZU1hY2hpbmVDaGFuZ2UgfSBmcm9tICcuL2hvdHN3YXAvc3RlcGZ1bmN0aW9ucy1zdGF0ZS1tYWNoaW5lcyc7XG5pbXBvcnQgeyBOZXN0ZWRTdGFja1RlbXBsYXRlcywgbG9hZEN1cnJlbnRUZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3MgfSBmcm9tICcuL25lc3RlZC1zdGFjay1oZWxwZXJzJztcbmltcG9ydCB7IE1vZGUgfSBmcm9tICcuL3BsdWdpbi9tb2RlJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uU3RhY2sgfSBmcm9tICcuL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHsgZm9ybWF0RXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vdXRpbC9lcnJvcic7XG5cbi8vIE11c3QgdXNlIGEgcmVxdWlyZSgpIG90aGVyd2lzZSBlc2J1aWxkIGNvbXBsYWlucyBhYm91dCBjYWxsaW5nIGEgbmFtZXNwYWNlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3QgcExpbWl0OiB0eXBlb2YgaW1wb3J0KCdwLWxpbWl0JykgPSByZXF1aXJlKCdwLWxpbWl0Jyk7XG5cbnR5cGUgSG90c3dhcERldGVjdG9yID0gKFxuICBsb2dpY2FsSWQ6IHN0cmluZyxcbiAgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4gIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbiAgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzOiBIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4pID0+IFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD47XG5cbmNvbnN0IFJFU09VUkNFX0RFVEVDVE9SUzogeyBba2V5OiBzdHJpbmddOiBIb3Rzd2FwRGV0ZWN0b3IgfSA9IHtcbiAgLy8gTGFtYmRhXG4gICdBV1M6OkxhbWJkYTo6RnVuY3Rpb24nOiBpc0hvdHN3YXBwYWJsZUxhbWJkYUZ1bmN0aW9uQ2hhbmdlLFxuICAnQVdTOjpMYW1iZGE6OlZlcnNpb24nOiBpc0hvdHN3YXBwYWJsZUxhbWJkYUZ1bmN0aW9uQ2hhbmdlLFxuICAnQVdTOjpMYW1iZGE6OkFsaWFzJzogaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSxcblxuICAvLyBBcHBTeW5jXG4gICdBV1M6OkFwcFN5bmM6OlJlc29sdmVyJzogaXNIb3Rzd2FwcGFibGVBcHBTeW5jQ2hhbmdlLFxuICAnQVdTOjpBcHBTeW5jOjpGdW5jdGlvbkNvbmZpZ3VyYXRpb24nOiBpc0hvdHN3YXBwYWJsZUFwcFN5bmNDaGFuZ2UsXG4gICdBV1M6OkFwcFN5bmM6OkdyYXBoUUxTY2hlbWEnOiBpc0hvdHN3YXBwYWJsZUFwcFN5bmNDaGFuZ2UsXG4gICdBV1M6OkFwcFN5bmM6OkFwaUtleSc6IGlzSG90c3dhcHBhYmxlQXBwU3luY0NoYW5nZSxcblxuICAnQVdTOjpFQ1M6OlRhc2tEZWZpbml0aW9uJzogaXNIb3Rzd2FwcGFibGVFY3NTZXJ2aWNlQ2hhbmdlLFxuICAnQVdTOjpDb2RlQnVpbGQ6OlByb2plY3QnOiBpc0hvdHN3YXBwYWJsZUNvZGVCdWlsZFByb2plY3RDaGFuZ2UsXG4gICdBV1M6OlN0ZXBGdW5jdGlvbnM6OlN0YXRlTWFjaGluZSc6IGlzSG90c3dhcHBhYmxlU3RhdGVNYWNoaW5lQ2hhbmdlLFxuICAnQ3VzdG9tOjpDREtCdWNrZXREZXBsb3ltZW50JzogaXNIb3Rzd2FwcGFibGVTM0J1Y2tldERlcGxveW1lbnRDaGFuZ2UsXG4gICdBV1M6OklBTTo6UG9saWN5JzogYXN5bmMgKFxuICAgIGxvZ2ljYWxJZDogc3RyaW5nLFxuICAgIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLFxuICAgIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbiAgKTogUHJvbWlzZTxDaGFuZ2VIb3Rzd2FwUmVzdWx0PiA9PiB7XG4gICAgLy8gSWYgdGhlIHBvbGljeSBpcyBmb3IgYSBTM0J1Y2tldERlcGxveW1lbnRDaGFuZ2UsIHdlIGNhbiBpZ25vcmUgdGhlIGNoYW5nZVxuICAgIGlmIChhd2FpdCBza2lwQ2hhbmdlRm9yUzNEZXBsb3lDdXN0b21SZXNvdXJjZVBvbGljeShsb2dpY2FsSWQsIGNoYW5nZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVwb3J0Tm9uSG90c3dhcHBhYmxlUmVzb3VyY2UoY2hhbmdlLCAnVGhpcyByZXNvdXJjZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGhvdHN3YXAgZGVwbG95bWVudHMnKTtcbiAgfSxcblxuICAnQVdTOjpDREs6Ok1ldGFkYXRhJzogYXN5bmMgKCkgPT4gW10sXG59O1xuXG4vKipcbiAqIFBlcmZvcm0gYSBob3Rzd2FwIGRlcGxveW1lbnQsIHNob3J0LWNpcmN1aXRpbmcgQ2xvdWRGb3JtYXRpb24gaWYgcG9zc2libGUuXG4gKiBJZiBpdCdzIG5vdCBwb3NzaWJsZSB0byBzaG9ydC1jaXJjdWl0IHRoZSBkZXBsb3ltZW50XG4gKiAoYmVjYXVzZSB0aGUgQ0RLIFN0YWNrIGNvbnRhaW5zIGNoYW5nZXMgdGhhdCBjYW5ub3QgYmUgZGVwbG95ZWQgd2l0aG91dCBDbG91ZEZvcm1hdGlvbiksXG4gKiByZXR1cm5zIGB1bmRlZmluZWRgLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJ5SG90c3dhcERlcGxveW1lbnQoXG4gIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgYXNzZXRQYXJhbXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sXG4gIGNsb3VkRm9ybWF0aW9uU3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2ssXG4gIHN0YWNrQXJ0aWZhY3Q6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCxcbiAgaG90c3dhcE1vZGU6IEhvdHN3YXBNb2RlLCBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbik6IFByb21pc2U8U3VjY2Vzc2Z1bERlcGxveVN0YWNrUmVzdWx0IHwgdW5kZWZpbmVkPiB7XG4gIC8vIHJlc29sdmUgdGhlIGVudmlyb25tZW50LCBzbyB3ZSBjYW4gc3Vic3RpdHV0ZSB0aGluZ3MgbGlrZSBBV1M6OlJlZ2lvbiBpbiBDRk4gZXhwcmVzc2lvbnNcbiAgY29uc3QgcmVzb2x2ZWRFbnYgPSBhd2FpdCBzZGtQcm92aWRlci5yZXNvbHZlRW52aXJvbm1lbnQoc3RhY2tBcnRpZmFjdC5lbnZpcm9ubWVudCk7XG4gIC8vIGNyZWF0ZSBhIG5ldyBTREsgdXNpbmcgdGhlIENMSSBjcmVkZW50aWFscywgYmVjYXVzZSB0aGUgZGVmYXVsdCBvbmUgd2lsbCBub3Qgd29yayBmb3IgbmV3LXN0eWxlIHN5bnRoZXNpcyAtXG4gIC8vIGl0IGFzc3VtZXMgdGhlIGJvb3RzdHJhcCBkZXBsb3kgUm9sZSwgd2hpY2ggZG9lc24ndCBoYXZlIHBlcm1pc3Npb25zIHRvIHVwZGF0ZSBMYW1iZGEgZnVuY3Rpb25zXG4gIGNvbnN0IHNkayA9IChhd2FpdCBzZGtQcm92aWRlci5mb3JFbnZpcm9ubWVudChyZXNvbHZlZEVudiwgTW9kZS5Gb3JXcml0aW5nKSkuc2RrO1xuXG4gIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZSA9IGF3YWl0IGxvYWRDdXJyZW50VGVtcGxhdGVXaXRoTmVzdGVkU3RhY2tzKHN0YWNrQXJ0aWZhY3QsIHNkayk7XG5cbiAgY29uc3QgZXZhbHVhdGVDZm5UZW1wbGF0ZSA9IG5ldyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUoe1xuICAgIHN0YWNrTmFtZTogc3RhY2tBcnRpZmFjdC5zdGFja05hbWUsXG4gICAgdGVtcGxhdGU6IHN0YWNrQXJ0aWZhY3QudGVtcGxhdGUsXG4gICAgcGFyYW1ldGVyczogYXNzZXRQYXJhbXMsXG4gICAgYWNjb3VudDogcmVzb2x2ZWRFbnYuYWNjb3VudCxcbiAgICByZWdpb246IHJlc29sdmVkRW52LnJlZ2lvbixcbiAgICBwYXJ0aXRpb246IChhd2FpdCBzZGsuY3VycmVudEFjY291bnQoKSkucGFydGl0aW9uLFxuICAgIHNkayxcbiAgICBuZXN0ZWRTdGFja3M6IGN1cnJlbnRUZW1wbGF0ZS5uZXN0ZWRTdGFja3MsXG4gIH0pO1xuXG4gIGNvbnN0IHN0YWNrQ2hhbmdlcyA9IGNmbl9kaWZmLmZ1bGxEaWZmKGN1cnJlbnRUZW1wbGF0ZS5kZXBsb3llZFJvb3RUZW1wbGF0ZSwgc3RhY2tBcnRpZmFjdC50ZW1wbGF0ZSk7XG4gIGNvbnN0IHsgaG90c3dhcHBhYmxlQ2hhbmdlcywgbm9uSG90c3dhcHBhYmxlQ2hhbmdlcyB9ID0gYXdhaXQgY2xhc3NpZnlSZXNvdXJjZUNoYW5nZXMoXG4gICAgc3RhY2tDaGFuZ2VzLFxuICAgIGV2YWx1YXRlQ2ZuVGVtcGxhdGUsXG4gICAgc2RrLFxuICAgIGN1cnJlbnRUZW1wbGF0ZS5uZXN0ZWRTdGFja3MsIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbiAgKTtcblxuICBsb2dOb25Ib3Rzd2FwcGFibGVDaGFuZ2VzKG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMsIGhvdHN3YXBNb2RlKTtcblxuICAvLyBwcmVzZXJ2ZSBjbGFzc2ljIGhvdHN3YXAgYmVoYXZpb3JcbiAgaWYgKGhvdHN3YXBNb2RlID09PSBIb3Rzd2FwTW9kZS5GQUxMX0JBQ0spIHtcbiAgICBpZiAobm9uSG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFwcGx5IHRoZSBzaG9ydC1jaXJjdWl0YWJsZSBjaGFuZ2VzXG4gIGF3YWl0IGFwcGx5QWxsSG90c3dhcHBhYmxlQ2hhbmdlcyhzZGssIGhvdHN3YXBwYWJsZUNoYW5nZXMpO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ2RpZC1kZXBsb3ktc3RhY2snLFxuICAgIG5vT3A6IGhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID09PSAwLFxuICAgIHN0YWNrQXJuOiBjbG91ZEZvcm1hdGlvblN0YWNrLnN0YWNrSWQsXG4gICAgb3V0cHV0czogY2xvdWRGb3JtYXRpb25TdGFjay5vdXRwdXRzLFxuICB9O1xufVxuXG4vKipcbiAqIENsYXNzaWZpZXMgYWxsIGNoYW5nZXMgdG8gYWxsIHJlc291cmNlcyBhcyBlaXRoZXIgaG90c3dhcHBhYmxlIG9yIG5vdC5cbiAqIE1ldGFkYXRhIGNoYW5nZXMgYXJlIGV4Y2x1ZGVkIGZyb20gdGhlIGxpc3Qgb2YgKG5vbilob3Rzd2FwcGFibGUgcmVzb3VyY2VzLlxuICovXG5hc3luYyBmdW5jdGlvbiBjbGFzc2lmeVJlc291cmNlQ2hhbmdlcyhcbiAgc3RhY2tDaGFuZ2VzOiBjZm5fZGlmZi5UZW1wbGF0ZURpZmYsXG4gIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbiAgc2RrOiBTREssXG4gIG5lc3RlZFN0YWNrTmFtZXM6IHsgW25lc3RlZFN0YWNrTmFtZTogc3RyaW5nXTogTmVzdGVkU3RhY2tUZW1wbGF0ZXMgfSxcbiAgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzOiBIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4pOiBQcm9taXNlPENsYXNzaWZpZWRSZXNvdXJjZUNoYW5nZXM+IHtcbiAgY29uc3QgcmVzb3VyY2VEaWZmZXJlbmNlcyA9IGdldFN0YWNrUmVzb3VyY2VEaWZmZXJlbmNlcyhzdGFja0NoYW5nZXMpO1xuXG4gIGNvbnN0IHByb21pc2VzOiBBcnJheTwoKSA9PiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+PiA9IFtdO1xuICBjb25zdCBob3Rzd2FwcGFibGVSZXNvdXJjZXMgPSBuZXcgQXJyYXk8SG90c3dhcHBhYmxlQ2hhbmdlPigpO1xuICBjb25zdCBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMgPSBuZXcgQXJyYXk8Tm9uSG90c3dhcHBhYmxlQ2hhbmdlPigpO1xuICBmb3IgKGNvbnN0IGxvZ2ljYWxJZCBvZiBPYmplY3Qua2V5cyhzdGFja0NoYW5nZXMub3V0cHV0cy5jaGFuZ2VzKSkge1xuICAgIG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKHtcbiAgICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgICByZWFzb246ICdvdXRwdXQgd2FzIGNoYW5nZWQnLFxuICAgICAgbG9naWNhbElkLFxuICAgICAgcmVqZWN0ZWRDaGFuZ2VzOiBbXSxcbiAgICAgIHJlc291cmNlVHlwZTogJ1N0YWNrIE91dHB1dCcsXG4gICAgfSk7XG4gIH1cbiAgLy8gZ2F0aGVyIHRoZSByZXN1bHRzIG9mIHRoZSBkZXRlY3RvciBmdW5jdGlvbnNcbiAgZm9yIChjb25zdCBbbG9naWNhbElkLCBjaGFuZ2VdIG9mIE9iamVjdC5lbnRyaWVzKHJlc291cmNlRGlmZmVyZW5jZXMpKSB7XG4gICAgaWYgKGNoYW5nZS5uZXdWYWx1ZT8uVHlwZSA9PT0gJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJyAmJiBjaGFuZ2Uub2xkVmFsdWU/LlR5cGUgPT09ICdBV1M6OkNsb3VkRm9ybWF0aW9uOjpTdGFjaycpIHtcbiAgICAgIGNvbnN0IG5lc3RlZEhvdHN3YXBwYWJsZVJlc291cmNlcyA9IGF3YWl0IGZpbmROZXN0ZWRIb3Rzd2FwcGFibGVDaGFuZ2VzKFxuICAgICAgICBsb2dpY2FsSWQsXG4gICAgICAgIGNoYW5nZSxcbiAgICAgICAgbmVzdGVkU3RhY2tOYW1lcyxcbiAgICAgICAgZXZhbHVhdGVDZm5UZW1wbGF0ZSxcbiAgICAgICAgc2RrLFxuICAgICAgICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4gICAgICApO1xuICAgICAgaG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2goLi4ubmVzdGVkSG90c3dhcHBhYmxlUmVzb3VyY2VzLmhvdHN3YXBwYWJsZUNoYW5nZXMpO1xuICAgICAgbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2goLi4ubmVzdGVkSG90c3dhcHBhYmxlUmVzb3VyY2VzLm5vbkhvdHN3YXBwYWJsZUNoYW5nZXMpO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUgPSBpc0NhbmRpZGF0ZUZvckhvdHN3YXBwaW5nKGNoYW5nZSwgbG9naWNhbElkKTtcbiAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHJ1biB0aGlzIHRocm91Z2ggdGhlIGRldGVjdG9yIGZ1bmN0aW9ucywgd2UgY2FuIGFscmVhZHkganVkZ2UgdGhpc1xuICAgIGlmICgnaG90c3dhcHBhYmxlJyBpbiBob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUpIHtcbiAgICAgIGlmICghaG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLmhvdHN3YXBwYWJsZSkge1xuICAgICAgICBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaChob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNvdXJjZVR5cGU6IHN0cmluZyA9IGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZS5uZXdWYWx1ZS5UeXBlO1xuICAgIGlmIChyZXNvdXJjZVR5cGUgaW4gUkVTT1VSQ0VfREVURUNUT1JTKSB7XG4gICAgICAvLyBydW4gZGV0ZWN0b3IgZnVuY3Rpb25zIGxhemlseSB0byBwcmV2ZW50IHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgICAgIHByb21pc2VzLnB1c2goKCkgPT5cbiAgICAgICAgUkVTT1VSQ0VfREVURUNUT1JTW3Jlc291cmNlVHlwZV0obG9naWNhbElkLCBob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUsIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyksXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UoXG4gICAgICAgIG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcyxcbiAgICAgICAgaG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICdUaGlzIHJlc291cmNlIHR5cGUgaXMgbm90IHN1cHBvcnRlZCBmb3IgaG90c3dhcCBkZXBsb3ltZW50cycsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlc29sdmUgYWxsIGRldGVjdG9yIHJlc3VsdHNcbiAgY29uc3QgY2hhbmdlc0RldGVjdGlvblJlc3VsdHM6IEFycmF5PENoYW5nZUhvdHN3YXBSZXN1bHQ+ID0gW107XG4gIGZvciAoY29uc3QgZGV0ZWN0b3JSZXN1bHRQcm9taXNlcyBvZiBwcm9taXNlcykge1xuICAgIC8vIENvbnN0YW50IHNldCBvZiBwcm9taXNlcyBwZXIgcmVzb3VyY2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgICBjb25zdCBob3Rzd2FwRGV0ZWN0aW9uUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGF3YWl0IGRldGVjdG9yUmVzdWx0UHJvbWlzZXMoKSk7XG4gICAgY2hhbmdlc0RldGVjdGlvblJlc3VsdHMucHVzaChob3Rzd2FwRGV0ZWN0aW9uUmVzdWx0cyk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHJlc291cmNlRGV0ZWN0aW9uUmVzdWx0cyBvZiBjaGFuZ2VzRGV0ZWN0aW9uUmVzdWx0cykge1xuICAgIGZvciAoY29uc3QgcHJvcGVydHlSZXN1bHQgb2YgcmVzb3VyY2VEZXRlY3Rpb25SZXN1bHRzKSB7XG4gICAgICBwcm9wZXJ0eVJlc3VsdC5ob3Rzd2FwcGFibGVcbiAgICAgICAgPyBob3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaChwcm9wZXJ0eVJlc3VsdClcbiAgICAgICAgOiBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaChwcm9wZXJ0eVJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBob3Rzd2FwcGFibGVDaGFuZ2VzOiBob3Rzd2FwcGFibGVSZXNvdXJjZXMsXG4gICAgbm9uSG90c3dhcHBhYmxlQ2hhbmdlczogbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLFxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYWxsIGNoYW5nZXMgdG8gcmVzb3VyY2VzIGluIHRoZSBnaXZlbiBTdGFjay5cbiAqXG4gKiBAcGFyYW0gc3RhY2tDaGFuZ2VzIHRoZSBjb2xsZWN0aW9uIG9mIGFsbCBjaGFuZ2VzIHRvIGEgZ2l2ZW4gU3RhY2tcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhY2tSZXNvdXJjZURpZmZlcmVuY2VzKHN0YWNrQ2hhbmdlczogY2ZuX2RpZmYuVGVtcGxhdGVEaWZmKToge1xuICBbbG9naWNhbElkOiBzdHJpbmddOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2U7XG59IHtcbiAgLy8gd2UgbmVlZCB0byBjb2xsYXBzZSBsb2dpY2FsIElEIHJlbmFtZSBjaGFuZ2VzIGludG8gb25lIGNoYW5nZSxcbiAgLy8gYXMgdGhleSBhcmUgcmVwcmVzZW50ZWQgaW4gc3RhY2tDaGFuZ2VzIGFzIGEgcGFpciBvZiB0d28gY2hhbmdlczogb25lIGFkZGl0aW9uIGFuZCBvbmUgcmVtb3ZhbFxuICBjb25zdCBhbGxSZXNvdXJjZUNoYW5nZXM6IHsgW2xvZ0lkOiBzdHJpbmddOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UgfSA9IHN0YWNrQ2hhbmdlcy5yZXNvdXJjZXMuY2hhbmdlcztcbiAgY29uc3QgYWxsUmVtb3ZhbENoYW5nZXMgPSBmaWx0ZXJEaWN0KGFsbFJlc291cmNlQ2hhbmdlcywgKHJlc0NoYW5nZSkgPT4gcmVzQ2hhbmdlLmlzUmVtb3ZhbCk7XG4gIGNvbnN0IGFsbE5vblJlbW92YWxDaGFuZ2VzID0gZmlsdGVyRGljdChhbGxSZXNvdXJjZUNoYW5nZXMsIChyZXNDaGFuZ2UpID0+ICFyZXNDaGFuZ2UuaXNSZW1vdmFsKTtcbiAgZm9yIChjb25zdCBbbG9nSWQsIG5vblJlbW92YWxDaGFuZ2VdIG9mIE9iamVjdC5lbnRyaWVzKGFsbE5vblJlbW92YWxDaGFuZ2VzKSkge1xuICAgIGlmIChub25SZW1vdmFsQ2hhbmdlLmlzQWRkaXRpb24pIHtcbiAgICAgIGNvbnN0IGFkZENoYW5nZSA9IG5vblJlbW92YWxDaGFuZ2U7XG4gICAgICAvLyBzZWFyY2ggZm9yIGFuIGlkZW50aWNhbCByZW1vdmFsIGNoYW5nZVxuICAgICAgY29uc3QgaWRlbnRpY2FsUmVtb3ZhbENoYW5nZSA9IE9iamVjdC5lbnRyaWVzKGFsbFJlbW92YWxDaGFuZ2VzKS5maW5kKChbXywgcmVtQ2hhbmdlXSkgPT4ge1xuICAgICAgICByZXR1cm4gY2hhbmdlc0FyZUZvclNhbWVSZXNvdXJjZShyZW1DaGFuZ2UsIGFkZENoYW5nZSk7XG4gICAgICB9KTtcbiAgICAgIC8vIGlmIHdlIGZvdW5kIG9uZSwgdGhlbiB0aGlzIG1lYW5zIHRoaXMgaXMgYSByZW5hbWUgY2hhbmdlXG4gICAgICBpZiAoaWRlbnRpY2FsUmVtb3ZhbENoYW5nZSkge1xuICAgICAgICBjb25zdCBbcmVtb3ZlZExvZ0lkLCByZW1vdmVkUmVzb3VyY2VDaGFuZ2VdID0gaWRlbnRpY2FsUmVtb3ZhbENoYW5nZTtcbiAgICAgICAgYWxsTm9uUmVtb3ZhbENoYW5nZXNbbG9nSWRdID0gbWFrZVJlbmFtZURpZmZlcmVuY2UocmVtb3ZlZFJlc291cmNlQ2hhbmdlLCBhZGRDaGFuZ2UpO1xuICAgICAgICAvLyBkZWxldGUgdGhlIHJlbW92YWwgY2hhbmdlIHRoYXQgZm9ybXMgdGhlIHJlbmFtZSBwYWlyXG4gICAgICAgIGRlbGV0ZSBhbGxSZW1vdmFsQ2hhbmdlc1tyZW1vdmVkTG9nSWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyB0aGUgZmluYWwgcmVzdWx0IGFyZSBhbGwgb2YgdGhlIHJlbWFpbmluZyByZW1vdmFsIGNoYW5nZXMsXG4gIC8vIHBsdXMgYWxsIG9mIHRoZSBub24tcmVtb3ZhbCBjaGFuZ2VzXG4gIC8vICh3ZSBzYXZlZCB0aGUgcmVuYW1lIGNoYW5nZXMgaW4gdGhhdCBvYmplY3QgYWxyZWFkeSlcbiAgcmV0dXJuIHtcbiAgICAuLi5hbGxSZW1vdmFsQ2hhbmdlcyxcbiAgICAuLi5hbGxOb25SZW1vdmFsQ2hhbmdlcyxcbiAgfTtcbn1cblxuLyoqIEZpbHRlcnMgYW4gb2JqZWN0IHdpdGggc3RyaW5nIGtleXMgYmFzZWQgb24gd2hldGhlciB0aGUgY2FsbGJhY2sgcmV0dXJucyAndHJ1ZScgZm9yIHRoZSBnaXZlbiB2YWx1ZSBpbiB0aGUgb2JqZWN0LiAqL1xuZnVuY3Rpb24gZmlsdGVyRGljdDxUPihkaWN0OiB7IFtrZXk6IHN0cmluZ106IFQgfSwgZnVuYzogKHQ6IFQpID0+IGJvb2xlYW4pOiB7IFtrZXk6IHN0cmluZ106IFQgfSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhkaWN0KS5yZWR1Y2UoXG4gICAgKGFjYywgW2tleSwgdF0pID0+IHtcbiAgICAgIGlmIChmdW5jKHQpKSB7XG4gICAgICAgIGFjY1trZXldID0gdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICB7fSBhcyB7IFtrZXk6IHN0cmluZ106IFQgfSxcbiAgKTtcbn1cblxuLyoqIEZpbmRzIGFueSBob3Rzd2FwcGFibGUgY2hhbmdlcyBpbiBhbGwgbmVzdGVkIHN0YWNrcy4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpbmROZXN0ZWRIb3Rzd2FwcGFibGVDaGFuZ2VzKFxuICBsb2dpY2FsSWQ6IHN0cmluZyxcbiAgY2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsXG4gIG5lc3RlZFN0YWNrVGVtcGxhdGVzOiB7IFtuZXN0ZWRTdGFja05hbWU6IHN0cmluZ106IE5lc3RlZFN0YWNrVGVtcGxhdGVzIH0sXG4gIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbiAgc2RrOiBTREssXG4gIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlczogSG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLFxuKTogUHJvbWlzZTxDbGFzc2lmaWVkUmVzb3VyY2VDaGFuZ2VzPiB7XG4gIGNvbnN0IG5lc3RlZFN0YWNrID0gbmVzdGVkU3RhY2tUZW1wbGF0ZXNbbG9naWNhbElkXTtcbiAgaWYgKCFuZXN0ZWRTdGFjay5waHlzaWNhbE5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaG90c3dhcHBhYmxlQ2hhbmdlczogW10sXG4gICAgICBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgICAgICAgIGxvZ2ljYWxJZCxcbiAgICAgICAgICByZWFzb246IGBwaHlzaWNhbCBuYW1lIGZvciBBV1M6OkNsb3VkRm9ybWF0aW9uOjpTdGFjayAnJHtsb2dpY2FsSWR9JyBjb3VsZCBub3QgYmUgZm91bmQgaW4gQ2xvdWRGb3JtYXRpb24sIHNvIHRoaXMgaXMgYSBuZXdseSBjcmVhdGVkIG5lc3RlZCBzdGFjayBhbmQgY2Fubm90IGJlIGhvdHN3YXBwZWRgLFxuICAgICAgICAgIHJlamVjdGVkQ2hhbmdlczogW10sXG4gICAgICAgICAgcmVzb3VyY2VUeXBlOiAnQVdTOjpDbG91ZEZvcm1hdGlvbjo6U3RhY2snLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgZXZhbHVhdGVOZXN0ZWRDZm5UZW1wbGF0ZSA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuY3JlYXRlTmVzdGVkRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlKFxuICAgIG5lc3RlZFN0YWNrLnBoeXNpY2FsTmFtZSxcbiAgICBuZXN0ZWRTdGFjay5nZW5lcmF0ZWRUZW1wbGF0ZSxcbiAgICBjaGFuZ2UubmV3VmFsdWU/LlByb3BlcnRpZXM/LlBhcmFtZXRlcnMsXG4gICk7XG5cbiAgY29uc3QgbmVzdGVkRGlmZiA9IGNmbl9kaWZmLmZ1bGxEaWZmKFxuICAgIG5lc3RlZFN0YWNrVGVtcGxhdGVzW2xvZ2ljYWxJZF0uZGVwbG95ZWRUZW1wbGF0ZSxcbiAgICBuZXN0ZWRTdGFja1RlbXBsYXRlc1tsb2dpY2FsSWRdLmdlbmVyYXRlZFRlbXBsYXRlLFxuICApO1xuXG4gIHJldHVybiBjbGFzc2lmeVJlc291cmNlQ2hhbmdlcyhcbiAgICBuZXN0ZWREaWZmLFxuICAgIGV2YWx1YXRlTmVzdGVkQ2ZuVGVtcGxhdGUsXG4gICAgc2RrLFxuICAgIG5lc3RlZFN0YWNrVGVtcGxhdGVzW2xvZ2ljYWxJZF0ubmVzdGVkU3RhY2tUZW1wbGF0ZXMsXG4gICAgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzKTtcbn1cblxuLyoqIFJldHVybnMgJ3RydWUnIGlmIGEgcGFpciBvZiBjaGFuZ2VzIGlzIGZvciB0aGUgc2FtZSByZXNvdXJjZS4gKi9cbmZ1bmN0aW9uIGNoYW5nZXNBcmVGb3JTYW1lUmVzb3VyY2UoXG4gIG9sZENoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLFxuICBuZXdDaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSxcbik6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIG9sZENoYW5nZS5vbGRSZXNvdXJjZVR5cGUgPT09IG5ld0NoYW5nZS5uZXdSZXNvdXJjZVR5cGUgJiZcbiAgICAvLyB0aGlzIGlzbid0IGdyZWF0LCBidXQgSSBkb24ndCB3YW50IHRvIGJyaW5nIGluIHNvbWV0aGluZyBsaWtlIHVuZGVyc2NvcmUganVzdCBmb3IgdGhpcyBjb21wYXJpc29uXG4gICAgSlNPTi5zdHJpbmdpZnkob2xkQ2hhbmdlLm9sZFByb3BlcnRpZXMpID09PSBKU09OLnN0cmluZ2lmeShuZXdDaGFuZ2UubmV3UHJvcGVydGllcylcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWFrZVJlbmFtZURpZmZlcmVuY2UoXG4gIHJlbUNoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLFxuICBhZGRDaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSxcbik6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSB7XG4gIHJldHVybiBuZXcgY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlKFxuICAgIC8vIHdlIGhhdmUgdG8gZmlsbCBpbiB0aGUgb2xkIHZhbHVlLCBiZWNhdXNlIG90aGVyd2lzZSB0aGlzIHdpbGwgYmUgY2xhc3NpZmllZCBhcyBhIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlXG4gICAgcmVtQ2hhbmdlLm9sZFZhbHVlLFxuICAgIGFkZENoYW5nZS5uZXdWYWx1ZSxcbiAgICB7XG4gICAgICByZXNvdXJjZVR5cGU6IHtcbiAgICAgICAgb2xkVHlwZTogcmVtQ2hhbmdlLm9sZFJlc291cmNlVHlwZSxcbiAgICAgICAgbmV3VHlwZTogYWRkQ2hhbmdlLm5ld1Jlc291cmNlVHlwZSxcbiAgICAgIH0sXG4gICAgICBwcm9wZXJ0eURpZmZzOiAoYWRkQ2hhbmdlIGFzIGFueSkucHJvcGVydHlEaWZmcyxcbiAgICAgIG90aGVyRGlmZnM6IChhZGRDaGFuZ2UgYXMgYW55KS5vdGhlckRpZmZzLFxuICAgIH0sXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGVgIGlmIHRoZSBjaGFuZ2UgaXMgaG90c3dhcHBhYmxlXG4gKiBSZXR1cm5zIGFuIGVtcHR5IGBIb3Rzd2FwcGFibGVDaGFuZ2VgIGlmIHRoZSBjaGFuZ2UgaXMgdG8gQ0RLOjpNZXRhZGF0YVxuICogUmV0dXJucyBhIGBOb25Ib3Rzd2FwcGFibGVDaGFuZ2VgIGlmIHRoZSBjaGFuZ2UgaXMgbm90IGhvdHN3YXBwYWJsZVxuICovXG5mdW5jdGlvbiBpc0NhbmRpZGF0ZUZvckhvdHN3YXBwaW5nKFxuICBjaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSxcbiAgbG9naWNhbElkOiBzdHJpbmcsXG4pOiBIb3Rzd2FwcGFibGVDaGFuZ2UgfCBOb25Ib3Rzd2FwcGFibGVDaGFuZ2UgfCBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUge1xuICAvLyBhIHJlc291cmNlIGhhcyBiZWVuIHJlbW92ZWQgT1IgYSByZXNvdXJjZSBoYXMgYmVlbiBhZGRlZDsgd2UgY2FuJ3Qgc2hvcnQtY2lyY3VpdCB0aGF0IGNoYW5nZVxuICBpZiAoIWNoYW5nZS5vbGRWYWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUhLlR5cGUsXG4gICAgICBsb2dpY2FsSWQsXG4gICAgICByZWplY3RlZENoYW5nZXM6IFtdLFxuICAgICAgcmVhc29uOiBgcmVzb3VyY2UgJyR7bG9naWNhbElkfScgd2FzIGNyZWF0ZWQgYnkgdGhpcyBkZXBsb3ltZW50YCxcbiAgICB9O1xuICB9IGVsc2UgaWYgKCFjaGFuZ2UubmV3VmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICAgIHJlc291cmNlVHlwZTogY2hhbmdlLm9sZFZhbHVlIS5UeXBlLFxuICAgICAgbG9naWNhbElkLFxuICAgICAgcmVqZWN0ZWRDaGFuZ2VzOiBbXSxcbiAgICAgIHJlYXNvbjogYHJlc291cmNlICcke2xvZ2ljYWxJZH0nIHdhcyBkZXN0cm95ZWQgYnkgdGhpcyBkZXBsb3ltZW50YCxcbiAgICB9O1xuICB9XG5cbiAgLy8gYSByZXNvdXJjZSBoYXMgaGFkIGl0cyB0eXBlIGNoYW5nZWRcbiAgaWYgKGNoYW5nZS5uZXdWYWx1ZT8uVHlwZSAhPT0gY2hhbmdlLm9sZFZhbHVlPy5UeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgICByZXNvdXJjZVR5cGU6IGNoYW5nZS5uZXdWYWx1ZT8uVHlwZSxcbiAgICAgIGxvZ2ljYWxJZCxcbiAgICAgIHJlamVjdGVkQ2hhbmdlczogW10sXG4gICAgICByZWFzb246IGByZXNvdXJjZSAnJHtsb2dpY2FsSWR9JyBoYWQgaXRzIHR5cGUgY2hhbmdlZCBmcm9tICcke2NoYW5nZS5vbGRWYWx1ZT8uVHlwZX0nIHRvICcke2NoYW5nZS5uZXdWYWx1ZT8uVHlwZX0nYCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsb2dpY2FsSWQsXG4gICAgb2xkVmFsdWU6IGNoYW5nZS5vbGRWYWx1ZSxcbiAgICBuZXdWYWx1ZTogY2hhbmdlLm5ld1ZhbHVlLFxuICAgIHByb3BlcnR5VXBkYXRlczogY2hhbmdlLnByb3BlcnR5VXBkYXRlcyxcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXBwbHlBbGxIb3Rzd2FwcGFibGVDaGFuZ2VzKHNkazogU0RLLCBob3Rzd2FwcGFibGVDaGFuZ2VzOiBIb3Rzd2FwcGFibGVDaGFuZ2VbXSk6IFByb21pc2U8dm9pZFtdPiB7XG4gIGlmIChob3Rzd2FwcGFibGVDaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICBpbmZvKGBcXG4ke0lDT059IGhvdHN3YXBwaW5nIHJlc291cmNlczpgKTtcbiAgfVxuICBjb25zdCBsaW1pdCA9IHBMaW1pdCgxMCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbVxuICByZXR1cm4gUHJvbWlzZS5hbGwoaG90c3dhcHBhYmxlQ2hhbmdlcy5tYXAoaG90c3dhcE9wZXJhdGlvbiA9PiBsaW1pdCgoKSA9PiB7XG4gICAgcmV0dXJuIGFwcGx5SG90c3dhcHBhYmxlQ2hhbmdlKHNkaywgaG90c3dhcE9wZXJhdGlvbik7XG4gIH0pKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5SG90c3dhcHBhYmxlQ2hhbmdlKHNkazogU0RLLCBob3Rzd2FwT3BlcmF0aW9uOiBIb3Rzd2FwcGFibGVDaGFuZ2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gbm90ZSB0aGUgdHlwZSBvZiBzZXJ2aWNlIHRoYXQgd2FzIHN1Y2Nlc3NmdWxseSBob3Rzd2FwcGVkIGluIHRoZSBVc2VyLUFnZW50XG4gIGNvbnN0IGN1c3RvbVVzZXJBZ2VudCA9IGBjZGstaG90c3dhcC9zdWNjZXNzLSR7aG90c3dhcE9wZXJhdGlvbi5zZXJ2aWNlfWA7XG4gIHNkay5hcHBlbmRDdXN0b21Vc2VyQWdlbnQoY3VzdG9tVXNlckFnZW50KTtcblxuICBmb3IgKGNvbnN0IG5hbWUgb2YgaG90c3dhcE9wZXJhdGlvbi5yZXNvdXJjZU5hbWVzKSB7XG4gICAgaW5mbyhgICAgJHtJQ09OfSAlc2AsIGNoYWxrLmJvbGQobmFtZSkpO1xuICB9XG5cbiAgLy8gaWYgdGhlIFNESyBjYWxsIGZhaWxzLCBhbiBlcnJvciB3aWxsIGJlIHRocm93biBieSB0aGUgU0RLXG4gIC8vIGFuZCB3aWxsIHByZXZlbnQgdGhlIGdyZWVuICdob3Rzd2FwcGVkIScgdGV4dCBmcm9tIGJlaW5nIGRpc3BsYXllZFxuICB0cnkge1xuICAgIGF3YWl0IGhvdHN3YXBPcGVyYXRpb24uYXBwbHkoc2RrKTtcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgaWYgKGUubmFtZSA9PT0gJ1RpbWVvdXRFcnJvcicgfHwgZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgIGNvbnN0IHJlc3VsdDogV2FpdGVyUmVzdWx0ID0gSlNPTi5wYXJzZShmb3JtYXRFcnJvck1lc3NhZ2UoZSkpO1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoW1xuICAgICAgICBgUmVzb3VyY2UgaXMgbm90IGluIHRoZSBleHBlY3RlZCBzdGF0ZSBkdWUgdG8gd2FpdGVyIHN0YXR1czogJHtyZXN1bHQuc3RhdGV9YCxcbiAgICAgICAgcmVzdWx0LnJlYXNvbiA/IGAke3Jlc3VsdC5yZWFzb259LmAgOiAnJyxcbiAgICAgIF0uam9pbignLiAnKSk7XG4gICAgICBlcnJvci5uYW1lID0gZS5uYW1lO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cblxuICBmb3IgKGNvbnN0IG5hbWUgb2YgaG90c3dhcE9wZXJhdGlvbi5yZXNvdXJjZU5hbWVzKSB7XG4gICAgaW5mbyhgJHtJQ09OfSAlcyAlc2AsIGNoYWxrLmJvbGQobmFtZSksIGNoYWxrLmdyZWVuKCdob3Rzd2FwcGVkIScpKTtcbiAgfVxuXG4gIHNkay5yZW1vdmVDdXN0b21Vc2VyQWdlbnQoY3VzdG9tVXNlckFnZW50KTtcbn1cblxuZnVuY3Rpb24gbG9nTm9uSG90c3dhcHBhYmxlQ2hhbmdlcyhub25Ib3Rzd2FwcGFibGVDaGFuZ2VzOiBOb25Ib3Rzd2FwcGFibGVDaGFuZ2VbXSwgaG90c3dhcE1vZGU6IEhvdHN3YXBNb2RlKTogdm9pZCB7XG4gIGlmIChub25Ib3Rzd2FwcGFibGVDaGFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvKipcbiAgICogRUtTIFNlcnZpY2VzIGNhbiBoYXZlIGEgdGFzayBkZWZpbml0aW9uIHRoYXQgZG9lc24ndCByZWZlciB0byB0aGUgdGFzayBkZWZpbml0aW9uIGJlaW5nIHVwZGF0ZWQuXG4gICAqIFdlIGhhdmUgdG8gbG9nIHRoaXMgYXMgYSBub24taG90c3dhcHBhYmxlIGNoYW5nZSB0byB0aGUgdGFzayBkZWZpbml0aW9uLCBidXQgd2hlbiB3ZSBkbyxcbiAgICogd2Ugd2luZCB1cCBob3Rzd2FwcGluZyB0aGUgdGFzayBkZWZpbml0aW9uIGFuZCBsb2dnaW5nIGl0IGFzIGEgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoaXMgbG9naWMgcHJldmVudHMgdXMgZnJvbSBsb2dnaW5nIHRoYXQgY2hhbmdlIGFzIG5vbi1ob3Rzd2FwcGFibGUgd2hlbiB3ZSBob3Rzd2FwIGl0LlxuICAgKi9cbiAgaWYgKGhvdHN3YXBNb2RlID09PSBIb3Rzd2FwTW9kZS5IT1RTV0FQX09OTFkpIHtcbiAgICBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzID0gbm9uSG90c3dhcHBhYmxlQ2hhbmdlcy5maWx0ZXIoKGNoYW5nZSkgPT4gY2hhbmdlLmhvdHN3YXBPbmx5VmlzaWJsZSA9PT0gdHJ1ZSk7XG5cbiAgICBpZiAobm9uSG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKGhvdHN3YXBNb2RlID09PSBIb3Rzd2FwTW9kZS5IT1RTV0FQX09OTFkpIHtcbiAgICBpbmZvKFxuICAgICAgJ1xcbiVzICVzJyxcbiAgICAgIGNoYWxrLnJlZCgn4pqg77iPJyksXG4gICAgICBjaGFsay5yZWQoXG4gICAgICAgICdUaGUgZm9sbG93aW5nIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlcyB3ZXJlIGZvdW5kLiBUbyByZWNvbmNpbGUgdGhlc2UgdXNpbmcgQ2xvdWRGb3JtYXRpb24sIHNwZWNpZnkgLS1ob3Rzd2FwLWZhbGxiYWNrJyxcbiAgICAgICksXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBpbmZvKCdcXG4lcyAlcycsIGNoYWxrLnJlZCgn4pqg77iPJyksIGNoYWxrLnJlZCgnVGhlIGZvbGxvd2luZyBub24taG90c3dhcHBhYmxlIGNoYW5nZXMgd2VyZSBmb3VuZDonKSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzKSB7XG4gICAgY2hhbmdlLnJlamVjdGVkQ2hhbmdlcy5sZW5ndGggPiAwXG4gICAgICA/IGluZm8oXG4gICAgICAgICcgICAgbG9naWNhbElEOiAlcywgdHlwZTogJXMsIHJlamVjdGVkIGNoYW5nZXM6ICVzLCByZWFzb246ICVzJyxcbiAgICAgICAgY2hhbGsuYm9sZChjaGFuZ2UubG9naWNhbElkKSxcbiAgICAgICAgY2hhbGsuYm9sZChjaGFuZ2UucmVzb3VyY2VUeXBlKSxcbiAgICAgICAgY2hhbGsuYm9sZChjaGFuZ2UucmVqZWN0ZWRDaGFuZ2VzKSxcbiAgICAgICAgY2hhbGsucmVkKGNoYW5nZS5yZWFzb24pLFxuICAgICAgKVxuICAgICAgOiBpbmZvKFxuICAgICAgICAnICAgIGxvZ2ljYWxJRDogJXMsIHR5cGU6ICVzLCByZWFzb246ICVzJyxcbiAgICAgICAgY2hhbGsuYm9sZChjaGFuZ2UubG9naWNhbElkKSxcbiAgICAgICAgY2hhbGsuYm9sZChjaGFuZ2UucmVzb3VyY2VUeXBlKSxcbiAgICAgICAgY2hhbGsucmVkKGNoYW5nZS5yZWFzb24pLFxuICAgICAgKTtcbiAgfVxuXG4gIGluZm8oJycpOyAvLyBuZXdsaW5lXG59XG4iXX0=