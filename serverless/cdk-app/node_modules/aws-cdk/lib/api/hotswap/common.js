"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassifiedChanges = exports.EcsHotswapProperties = exports.HotswapPropertyOverrides = exports.HotswappableChangeCandidate = exports.HotswapMode = exports.ICON = void 0;
exports.transformObjectKeys = transformObjectKeys;
exports.lowerCaseFirstCharacter = lowerCaseFirstCharacter;
exports.classifyChanges = classifyChanges;
exports.reportNonHotswappableChange = reportNonHotswappableChange;
exports.reportNonHotswappableResource = reportNonHotswappableResource;
const error_1 = require("../../toolkit/error");
exports.ICON = 'âœ¨';
var HotswapMode;
(function (HotswapMode) {
    /**
     * Will fall back to CloudFormation when a non-hotswappable change is detected
     */
    HotswapMode["FALL_BACK"] = "fall-back";
    /**
     * Will not fall back to CloudFormation when a non-hotswappable change is detected
     */
    HotswapMode["HOTSWAP_ONLY"] = "hotswap-only";
    /**
     * Will not attempt to hotswap anything and instead go straight to CloudFormation
     */
    HotswapMode["FULL_DEPLOYMENT"] = "full-deployment";
})(HotswapMode || (exports.HotswapMode = HotswapMode = {}));
/**
 * Represents a change that can be hotswapped.
 */
class HotswappableChangeCandidate {
    constructor(logicalId, oldValue, newValue, propertyUpdates) {
        this.logicalId = logicalId;
        this.oldValue = oldValue;
        this.newValue = newValue;
        this.propertyUpdates = propertyUpdates;
    }
}
exports.HotswappableChangeCandidate = HotswappableChangeCandidate;
/**
 * Represents configuration property overrides for hotswap deployments
 */
class HotswapPropertyOverrides {
    constructor(ecsHotswapProperties) {
        this.ecsHotswapProperties = ecsHotswapProperties;
    }
}
exports.HotswapPropertyOverrides = HotswapPropertyOverrides;
/**
 * Represents configuration properties for ECS hotswap deployments
 */
class EcsHotswapProperties {
    constructor(minimumHealthyPercent, maximumHealthyPercent) {
        if (minimumHealthyPercent !== undefined && minimumHealthyPercent < 0) {
            throw new error_1.ToolkitError('hotswap-ecs-minimum-healthy-percent can\'t be a negative number');
        }
        if (maximumHealthyPercent !== undefined && maximumHealthyPercent < 0) {
            throw new error_1.ToolkitError('hotswap-ecs-maximum-healthy-percent can\'t be a negative number');
        }
        // In order to preserve the current behaviour, when minimumHealthyPercent is not defined, it will be set to the currently default value of 0
        if (minimumHealthyPercent == undefined) {
            this.minimumHealthyPercent = 0;
        }
        else {
            this.minimumHealthyPercent = minimumHealthyPercent;
        }
        this.maximumHealthyPercent = maximumHealthyPercent;
    }
    /**
     * Check if any hotswap properties are defined
     * @returns true if all properties are undefined, false otherwise
    */
    isEmpty() {
        return this.minimumHealthyPercent === 0 && this.maximumHealthyPercent === undefined;
    }
}
exports.EcsHotswapProperties = EcsHotswapProperties;
/**
 * This function transforms all keys (recursively) in the provided `val` object.
 *
 * @param val The object whose keys need to be transformed.
 * @param transform The function that will be applied to each key.
 * @param exclude The keys that will not be transformed and copied to output directly
 * @returns A new object with the same values as `val`, but with all keys transformed according to `transform`.
 */
function transformObjectKeys(val, transform, exclude = {}) {
    if (val == null || typeof val !== 'object') {
        return val;
    }
    if (Array.isArray(val)) {
        // For arrays we just pass parent's exclude object directly
        // since it makes no sense to specify different exclude options for each array element
        return val.map((input) => transformObjectKeys(input, transform, exclude));
    }
    const ret = {};
    for (const [k, v] of Object.entries(val)) {
        const childExclude = exclude[k];
        if (childExclude === true) {
            // we don't transform this object if the key is specified in exclude
            ret[transform(k)] = v;
        }
        else {
            ret[transform(k)] = transformObjectKeys(v, transform, childExclude);
        }
    }
    return ret;
}
/**
 * This function lower cases the first character of the string provided.
 */
function lowerCaseFirstCharacter(str) {
    return str.length > 0 ? `${str[0].toLowerCase()}${str.slice(1)}` : str;
}
class ClassifiedChanges {
    constructor(change, hotswappableProps, nonHotswappableProps) {
        this.change = change;
        this.hotswappableProps = hotswappableProps;
        this.nonHotswappableProps = nonHotswappableProps;
    }
    reportNonHotswappablePropertyChanges(ret) {
        const nonHotswappablePropNames = Object.keys(this.nonHotswappableProps);
        if (nonHotswappablePropNames.length > 0) {
            const tagOnlyChange = nonHotswappablePropNames.length === 1 && nonHotswappablePropNames[0] === 'Tags';
            reportNonHotswappableChange(ret, this.change, this.nonHotswappableProps, tagOnlyChange
                ? 'Tags are not hotswappable'
                : `resource properties '${nonHotswappablePropNames}' are not hotswappable on this resource type`);
        }
    }
    get namesOfHotswappableProps() {
        return Object.keys(this.hotswappableProps);
    }
}
exports.ClassifiedChanges = ClassifiedChanges;
function classifyChanges(xs, hotswappablePropNames) {
    const hotswappableProps = {};
    const nonHotswappableProps = {};
    for (const [name, propDiff] of Object.entries(xs.propertyUpdates)) {
        if (hotswappablePropNames.includes(name)) {
            hotswappableProps[name] = propDiff;
        }
        else {
            nonHotswappableProps[name] = propDiff;
        }
    }
    return new ClassifiedChanges(xs, hotswappableProps, nonHotswappableProps);
}
function reportNonHotswappableChange(ret, change, nonHotswappableProps, reason, hotswapOnlyVisible) {
    let hotswapOnlyVisibility = true;
    if (hotswapOnlyVisible === false) {
        hotswapOnlyVisibility = false;
    }
    ret.push({
        hotswappable: false,
        rejectedChanges: Object.keys(nonHotswappableProps ?? change.propertyUpdates),
        logicalId: change.logicalId,
        resourceType: change.newValue.Type,
        reason,
        hotswapOnlyVisible: hotswapOnlyVisibility,
    });
}
function reportNonHotswappableResource(change, reason) {
    return [
        {
            hotswappable: false,
            rejectedChanges: Object.keys(change.propertyUpdates),
            logicalId: change.logicalId,
            resourceType: change.newValue.Type,
            reason,
        },
    ];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tbW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQTJKQSxrREFvQkM7QUFLRCwwREFFQztBQStCRCwwQ0FhQztBQUVELGtFQW1CQztBQUVELHNFQWFDO0FBclFELCtDQUFtRDtBQUd0QyxRQUFBLElBQUksR0FBRyxHQUFHLENBQUM7QUE4Q3hCLElBQVksV0FlWDtBQWZELFdBQVksV0FBVztJQUNyQjs7T0FFRztJQUNILHNDQUF1QixDQUFBO0lBRXZCOztPQUVHO0lBQ0gsNENBQTZCLENBQUE7SUFFN0I7O09BRUc7SUFDSCxrREFBbUMsQ0FBQTtBQUNyQyxDQUFDLEVBZlcsV0FBVywyQkFBWCxXQUFXLFFBZXRCO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLDJCQUEyQjtJQXFCdEMsWUFBbUIsU0FBaUIsRUFBRSxRQUFrQixFQUFFLFFBQWtCLEVBQUUsZUFBMEI7UUFDdEcsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFDM0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7SUFDekMsQ0FBQztDQUNGO0FBM0JELGtFQTJCQztBQUlEOztHQUVHO0FBQ0gsTUFBYSx3QkFBd0I7SUFJbkMsWUFBb0Isb0JBQTJDO1FBQzdELElBQUksQ0FBQyxvQkFBb0IsR0FBRyxvQkFBb0IsQ0FBQztJQUNuRCxDQUFDO0NBQ0Y7QUFQRCw0REFPQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxvQkFBb0I7SUFNL0IsWUFBb0IscUJBQThCLEVBQUUscUJBQThCO1FBQ2hGLElBQUkscUJBQXFCLEtBQUssU0FBUyxJQUFJLHFCQUFxQixHQUFHLENBQUMsRUFBRyxDQUFDO1lBQ3RFLE1BQU0sSUFBSSxvQkFBWSxDQUFDLGlFQUFpRSxDQUFDLENBQUM7UUFDNUYsQ0FBQztR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S0FBSyxFQUFFLENBQUM7UUFDakMscUJBQXFCLEdBQUcsS0FBSyxDQUFDO0lBQ2hDLENBQUM7SUFDRCxHQUFHLENBQUMsSUFBSSxDQUFDO1FBQ1AsWUFBWSxFQUFFLEtBQUs7UUFDbkIsZUFBZSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0JBQW9CLElBQUksTUFBTSxDQUFDLGVBQWUsQ0FBQztRQUM1RSxTQUFTLEVBQUUsTUFBTSxDQUFDLFNBQVM7UUFDM0IsWUFBWSxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSTtRQUNsQyxNQUFNO1FBQ04sa0JBQWtCLEVBQUUscUJBQXFCO0tBQzFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxTQUFnQiw2QkFBNkIsQ0FDM0MsTUFBbUMsRUFDbkMsTUFBZTtJQUVmLE9BQU87UUFDTDtZQUNFLFlBQVksRUFBRSxLQUFLO1lBQ25CLGVBQWUsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUM7WUFDcEQsU0FBUyxFQUFFLE1BQU0sQ0FBQyxTQUFTO1lBQzNCLFlBQVksRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUk7WUFDbEMsTUFBTTtTQUNQO0tBQ0YsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFByb3BlcnR5RGlmZmVyZW5jZSwgUmVzb3VyY2UgfSBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uL3Rvb2xraXQvZXJyb3InO1xuaW1wb3J0IHR5cGUgeyBTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5cbmV4cG9ydCBjb25zdCBJQ09OID0gJ+KcqCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSG90c3dhcHBhYmxlQ2hhbmdlIHtcbiAgcmVhZG9ubHkgaG90c3dhcHBhYmxlOiB0cnVlO1xuICByZWFkb25seSByZXNvdXJjZVR5cGU6IHN0cmluZztcbiAgcmVhZG9ubHkgcHJvcHNDaGFuZ2VkOiBBcnJheTxzdHJpbmc+O1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHNlcnZpY2UgYmVpbmcgaG90c3dhcHBlZC5cbiAgICogVXNlZCB0byBzZXQgYSBjdXN0b20gVXNlci1BZ2VudCBmb3IgU0RLIGNhbGxzLlxuICAgKi9cbiAgcmVhZG9ubHkgc2VydmljZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgb2YgdGhlIHJlc291cmNlcyBiZWluZyBob3Rzd2FwcGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VOYW1lczogc3RyaW5nW107XG5cbiAgcmVhZG9ubHkgYXBwbHk6IChzZGs6IFNESykgPT4gUHJvbWlzZTx2b2lkPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb25Ib3Rzd2FwcGFibGVDaGFuZ2Uge1xuICByZWFkb25seSBob3Rzd2FwcGFibGU6IGZhbHNlO1xuICByZWFkb25seSByZXNvdXJjZVR5cGU6IHN0cmluZztcbiAgcmVhZG9ubHkgcmVqZWN0ZWRDaGFuZ2VzOiBBcnJheTxzdHJpbmc+O1xuICByZWFkb25seSBsb2dpY2FsSWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRlbGxzIHRoZSB1c2VyIGV4YWN0bHkgd2h5IHRoaXMgY2hhbmdlIHdhcyBkZWVtZWQgbm9uLWhvdHN3YXBwYWJsZSBhbmQgd2hhdCBpdHMgbG9naWNhbCBJRCBpcy5cbiAgICogSWYgbm90IHNwZWNpZmllZCwgYHJlYXNvbmAgd2lsbCBiZSBhdXRvZmlsbGVkIHRvIHN0YXRlIHRoYXQgdGhlIHByb3BlcnRpZXMgbGlzdGVkIGluIGByZWplY3RlZENoYW5nZXNgIGFyZSBub3QgaG90c3dhcHBhYmxlLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVhc29uPzogc3RyaW5nO1xuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdG8gc2hvdyB0aGlzIGNoYW5nZSB3aGVuIGxpc3Rpbmcgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2VzIGluIEhPVFNXQVBfT05MWSBtb2RlLiBEb2VzIG5vdCBhZmZlY3RcbiAgICogbGlzdGluZyBpbiBGQUxMX0JBQ0sgbW9kZS5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgaG90c3dhcE9ubHlWaXNpYmxlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IHR5cGUgQ2hhbmdlSG90c3dhcFJlc3VsdCA9IEFycmF5PEhvdHN3YXBwYWJsZUNoYW5nZSB8IE5vbkhvdHN3YXBwYWJsZUNoYW5nZT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xhc3NpZmllZFJlc291cmNlQ2hhbmdlcyB7XG4gIGhvdHN3YXBwYWJsZUNoYW5nZXM6IEhvdHN3YXBwYWJsZUNoYW5nZVtdO1xuICBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzOiBOb25Ib3Rzd2FwcGFibGVDaGFuZ2VbXTtcbn1cblxuZXhwb3J0IGVudW0gSG90c3dhcE1vZGUge1xuICAvKipcbiAgICogV2lsbCBmYWxsIGJhY2sgdG8gQ2xvdWRGb3JtYXRpb24gd2hlbiBhIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlIGlzIGRldGVjdGVkXG4gICAqL1xuICBGQUxMX0JBQ0sgPSAnZmFsbC1iYWNrJyxcblxuICAvKipcbiAgICogV2lsbCBub3QgZmFsbCBiYWNrIHRvIENsb3VkRm9ybWF0aW9uIHdoZW4gYSBub24taG90c3dhcHBhYmxlIGNoYW5nZSBpcyBkZXRlY3RlZFxuICAgKi9cbiAgSE9UU1dBUF9PTkxZID0gJ2hvdHN3YXAtb25seScsXG5cbiAgLyoqXG4gICAqIFdpbGwgbm90IGF0dGVtcHQgdG8gaG90c3dhcCBhbnl0aGluZyBhbmQgaW5zdGVhZCBnbyBzdHJhaWdodCB0byBDbG91ZEZvcm1hdGlvblxuICAgKi9cbiAgRlVMTF9ERVBMT1lNRU5UID0gJ2Z1bGwtZGVwbG95bWVudCcsXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNoYW5nZSB0aGF0IGNhbiBiZSBob3Rzd2FwcGVkLlxuICovXG5leHBvcnQgY2xhc3MgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlIHtcbiAgLyoqXG4gICAqIFRoZSBsb2dpY2FsIElEIG9mIHRoZSByZXNvdXJjZSB3aGljaCBpcyBiZWluZyBjaGFuZ2VkXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbG9naWNhbElkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSB0aGUgcmVzb3VyY2UgaXMgYmVpbmcgdXBkYXRlZCBmcm9tXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgb2xkVmFsdWU6IFJlc291cmNlO1xuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgdGhlIHJlc291cmNlIGlzIGJlaW5nIHVwZGF0ZWQgdG9cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBuZXdWYWx1ZTogUmVzb3VyY2U7XG5cbiAgLyoqXG4gICAqIFRoZSBjaGFuZ2VzIG1hZGUgdG8gdGhlIHJlc291cmNlIHByb3BlcnRpZXNcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwcm9wZXJ0eVVwZGF0ZXM6IFByb3BEaWZmcztcblxuICBwdWJsaWMgY29uc3RydWN0b3IobG9naWNhbElkOiBzdHJpbmcsIG9sZFZhbHVlOiBSZXNvdXJjZSwgbmV3VmFsdWU6IFJlc291cmNlLCBwcm9wZXJ0eVVwZGF0ZXM6IFByb3BEaWZmcykge1xuICAgIHRoaXMubG9naWNhbElkID0gbG9naWNhbElkO1xuICAgIHRoaXMub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICB0aGlzLm5ld1ZhbHVlID0gbmV3VmFsdWU7XG4gICAgdGhpcy5wcm9wZXJ0eVVwZGF0ZXMgPSBwcm9wZXJ0eVVwZGF0ZXM7XG4gIH1cbn1cblxudHlwZSBFeGNsdWRlID0geyBba2V5OiBzdHJpbmddOiBFeGNsdWRlIHwgdHJ1ZSB9O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgY29uZmlndXJhdGlvbiBwcm9wZXJ0eSBvdmVycmlkZXMgZm9yIGhvdHN3YXAgZGVwbG95bWVudHNcbiAqL1xuZXhwb3J0IGNsYXNzIEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyB7XG4gIC8vIEVhY2ggc3VwcG9ydGVkIHJlc291cmNlIHR5cGUgd2lsbCBoYXZlIGl0cyBvd24gcHJvcGVydGllcy4gQ3VycmVudGx5IHRoaXMgaXMgRUNTXG4gIGVjc0hvdHN3YXBQcm9wZXJ0aWVzPzogRWNzSG90c3dhcFByb3BlcnRpZXM7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yIChlY3NIb3Rzd2FwUHJvcGVydGllcz86IEVjc0hvdHN3YXBQcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy5lY3NIb3Rzd2FwUHJvcGVydGllcyA9IGVjc0hvdHN3YXBQcm9wZXJ0aWVzO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgZm9yIEVDUyBob3Rzd2FwIGRlcGxveW1lbnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBFY3NIb3Rzd2FwUHJvcGVydGllcyB7XG4gIC8vIFRoZSBsb3dlciBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIHlvdXIgc2VydmljZSdzIHRhc2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIFJVTk5JTkcgc3RhdGUgZHVyaW5nIGEgZGVwbG95bWVudCwgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBkZXNpcmVkQ291bnRcbiAgcmVhZG9ubHkgbWluaW11bUhlYWx0aHlQZXJjZW50PzogbnVtYmVyO1xuICAvLyBUaGUgdXBwZXIgbGltaXQgb24gdGhlIG51bWJlciBvZiB5b3VyIHNlcnZpY2UncyB0YXNrcyB0aGF0IGFyZSBhbGxvd2VkIGluIHRoZSBSVU5OSU5HIG9yIFBFTkRJTkcgc3RhdGUgZHVyaW5nIGEgZGVwbG95bWVudCwgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBkZXNpcmVkQ291bnRcbiAgcmVhZG9ubHkgbWF4aW11bUhlYWx0aHlQZXJjZW50PzogbnVtYmVyO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciAobWluaW11bUhlYWx0aHlQZXJjZW50PzogbnVtYmVyLCBtYXhpbXVtSGVhbHRoeVBlcmNlbnQ/OiBudW1iZXIpIHtcbiAgICBpZiAobWluaW11bUhlYWx0aHlQZXJjZW50ICE9PSB1bmRlZmluZWQgJiYgbWluaW11bUhlYWx0aHlQZXJjZW50IDwgMCApIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ2hvdHN3YXAtZWNzLW1pbmltdW0taGVhbHRoeS1wZXJjZW50IGNhblxcJ3QgYmUgYSBuZWdhdGl2ZSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKG1heGltdW1IZWFsdGh5UGVyY2VudCAhPT0gdW5kZWZpbmVkICYmIG1heGltdW1IZWFsdGh5UGVyY2VudCA8IDAgKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdob3Rzd2FwLWVjcy1tYXhpbXVtLWhlYWx0aHktcGVyY2VudCBjYW5cXCd0IGJlIGEgbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgfVxuICAgIC8vIEluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSBjdXJyZW50IGJlaGF2aW91ciwgd2hlbiBtaW5pbXVtSGVhbHRoeVBlcmNlbnQgaXMgbm90IGRlZmluZWQsIGl0IHdpbGwgYmUgc2V0IHRvIHRoZSBjdXJyZW50bHkgZGVmYXVsdCB2YWx1ZSBvZiAwXG4gICAgaWYgKG1pbmltdW1IZWFsdGh5UGVyY2VudCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubWluaW11bUhlYWx0aHlQZXJjZW50ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5taW5pbXVtSGVhbHRoeVBlcmNlbnQgPSBtaW5pbXVtSGVhbHRoeVBlcmNlbnQ7XG4gICAgfVxuICAgIHRoaXMubWF4aW11bUhlYWx0aHlQZXJjZW50ID0gbWF4aW11bUhlYWx0aHlQZXJjZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFueSBob3Rzd2FwIHByb3BlcnRpZXMgYXJlIGRlZmluZWRcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBhbGwgcHJvcGVydGllcyBhcmUgdW5kZWZpbmVkLCBmYWxzZSBvdGhlcndpc2VcbiAgKi9cbiAgcHVibGljIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubWluaW11bUhlYWx0aHlQZXJjZW50ID09PSAwICYmIHRoaXMubWF4aW11bUhlYWx0aHlQZXJjZW50ID09PSB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyYW5zZm9ybXMgYWxsIGtleXMgKHJlY3Vyc2l2ZWx5KSBpbiB0aGUgcHJvdmlkZWQgYHZhbGAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWwgVGhlIG9iamVjdCB3aG9zZSBrZXlzIG5lZWQgdG8gYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0gdHJhbnNmb3JtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBlYWNoIGtleS5cbiAqIEBwYXJhbSBleGNsdWRlIFRoZSBrZXlzIHRoYXQgd2lsbCBub3QgYmUgdHJhbnNmb3JtZWQgYW5kIGNvcGllZCB0byBvdXRwdXQgZGlyZWN0bHlcbiAqIEByZXR1cm5zIEEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyBgdmFsYCwgYnV0IHdpdGggYWxsIGtleXMgdHJhbnNmb3JtZWQgYWNjb3JkaW5nIHRvIGB0cmFuc2Zvcm1gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtT2JqZWN0S2V5cyh2YWw6IGFueSwgdHJhbnNmb3JtOiAoc3RyOiBzdHJpbmcpID0+IHN0cmluZywgZXhjbHVkZTogRXhjbHVkZSA9IHt9KTogYW55IHtcbiAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgLy8gRm9yIGFycmF5cyB3ZSBqdXN0IHBhc3MgcGFyZW50J3MgZXhjbHVkZSBvYmplY3QgZGlyZWN0bHlcbiAgICAvLyBzaW5jZSBpdCBtYWtlcyBubyBzZW5zZSB0byBzcGVjaWZ5IGRpZmZlcmVudCBleGNsdWRlIG9wdGlvbnMgZm9yIGVhY2ggYXJyYXkgZWxlbWVudFxuICAgIHJldHVybiB2YWwubWFwKChpbnB1dDogYW55KSA9PiB0cmFuc2Zvcm1PYmplY3RLZXlzKGlucHV0LCB0cmFuc2Zvcm0sIGV4Y2x1ZGUpKTtcbiAgfVxuICBjb25zdCByZXQ6IHsgW2s6IHN0cmluZ106IGFueSB9ID0ge307XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHZhbCkpIHtcbiAgICBjb25zdCBjaGlsZEV4Y2x1ZGUgPSBleGNsdWRlW2tdO1xuICAgIGlmIChjaGlsZEV4Y2x1ZGUgPT09IHRydWUpIHtcbiAgICAgIC8vIHdlIGRvbid0IHRyYW5zZm9ybSB0aGlzIG9iamVjdCBpZiB0aGUga2V5IGlzIHNwZWNpZmllZCBpbiBleGNsdWRlXG4gICAgICByZXRbdHJhbnNmb3JtKGspXSA9IHY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFt0cmFuc2Zvcm0oayldID0gdHJhbnNmb3JtT2JqZWN0S2V5cyh2LCB0cmFuc2Zvcm0sIGNoaWxkRXhjbHVkZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBsb3dlciBjYXNlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb3dlckNhc2VGaXJzdENoYXJhY3RlcihzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIubGVuZ3RoID4gMCA/IGAke3N0clswXS50b0xvd2VyQ2FzZSgpfSR7c3RyLnNsaWNlKDEpfWAgOiBzdHI7XG59XG5cbmV4cG9ydCB0eXBlIFByb3BEaWZmcyA9IFJlY29yZDxzdHJpbmcsIFByb3BlcnR5RGlmZmVyZW5jZTxhbnk+PjtcblxuZXhwb3J0IGNsYXNzIENsYXNzaWZpZWRDaGFuZ2VzIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgaG90c3dhcHBhYmxlUHJvcHM6IFByb3BEaWZmcyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgbm9uSG90c3dhcHBhYmxlUHJvcHM6IFByb3BEaWZmcyxcbiAgKSB7fVxuXG4gIHB1YmxpYyByZXBvcnROb25Ib3Rzd2FwcGFibGVQcm9wZXJ0eUNoYW5nZXMocmV0OiBDaGFuZ2VIb3Rzd2FwUmVzdWx0KTogdm9pZCB7XG4gICAgY29uc3Qgbm9uSG90c3dhcHBhYmxlUHJvcE5hbWVzID0gT2JqZWN0LmtleXModGhpcy5ub25Ib3Rzd2FwcGFibGVQcm9wcyk7XG4gICAgaWYgKG5vbkhvdHN3YXBwYWJsZVByb3BOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0YWdPbmx5Q2hhbmdlID0gbm9uSG90c3dhcHBhYmxlUHJvcE5hbWVzLmxlbmd0aCA9PT0gMSAmJiBub25Ib3Rzd2FwcGFibGVQcm9wTmFtZXNbMF0gPT09ICdUYWdzJztcbiAgICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShcbiAgICAgICAgcmV0LFxuICAgICAgICB0aGlzLmNoYW5nZSxcbiAgICAgICAgdGhpcy5ub25Ib3Rzd2FwcGFibGVQcm9wcyxcbiAgICAgICAgdGFnT25seUNoYW5nZVxuICAgICAgICAgID8gJ1RhZ3MgYXJlIG5vdCBob3Rzd2FwcGFibGUnXG4gICAgICAgICAgOiBgcmVzb3VyY2UgcHJvcGVydGllcyAnJHtub25Ib3Rzd2FwcGFibGVQcm9wTmFtZXN9JyBhcmUgbm90IGhvdHN3YXBwYWJsZSBvbiB0aGlzIHJlc291cmNlIHR5cGVgLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IG5hbWVzT2ZIb3Rzd2FwcGFibGVQcm9wcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaG90c3dhcHBhYmxlUHJvcHMpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFzc2lmeUNoYW5nZXMoeHM6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgaG90c3dhcHBhYmxlUHJvcE5hbWVzOiBzdHJpbmdbXSk6IENsYXNzaWZpZWRDaGFuZ2VzIHtcbiAgY29uc3QgaG90c3dhcHBhYmxlUHJvcHM6IFByb3BEaWZmcyA9IHt9O1xuICBjb25zdCBub25Ib3Rzd2FwcGFibGVQcm9wczogUHJvcERpZmZzID0ge307XG5cbiAgZm9yIChjb25zdCBbbmFtZSwgcHJvcERpZmZdIG9mIE9iamVjdC5lbnRyaWVzKHhzLnByb3BlcnR5VXBkYXRlcykpIHtcbiAgICBpZiAoaG90c3dhcHBhYmxlUHJvcE5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICBob3Rzd2FwcGFibGVQcm9wc1tuYW1lXSA9IHByb3BEaWZmO1xuICAgIH0gZWxzZSB7XG4gICAgICBub25Ib3Rzd2FwcGFibGVQcm9wc1tuYW1lXSA9IHByb3BEaWZmO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQ2xhc3NpZmllZENoYW5nZXMoeHMsIGhvdHN3YXBwYWJsZVByb3BzLCBub25Ib3Rzd2FwcGFibGVQcm9wcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UoXG4gIHJldDogQ2hhbmdlSG90c3dhcFJlc3VsdCxcbiAgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4gIG5vbkhvdHN3YXBwYWJsZVByb3BzPzogUHJvcERpZmZzLFxuICByZWFzb24/OiBzdHJpbmcsXG4gIGhvdHN3YXBPbmx5VmlzaWJsZT86IGJvb2xlYW4sXG4pOiB2b2lkIHtcbiAgbGV0IGhvdHN3YXBPbmx5VmlzaWJpbGl0eSA9IHRydWU7XG4gIGlmIChob3Rzd2FwT25seVZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgaG90c3dhcE9ubHlWaXNpYmlsaXR5ID0gZmFsc2U7XG4gIH1cbiAgcmV0LnB1c2goe1xuICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgcmVqZWN0ZWRDaGFuZ2VzOiBPYmplY3Qua2V5cyhub25Ib3Rzd2FwcGFibGVQcm9wcyA/PyBjaGFuZ2UucHJvcGVydHlVcGRhdGVzKSxcbiAgICBsb2dpY2FsSWQ6IGNoYW5nZS5sb2dpY2FsSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICByZWFzb24sXG4gICAgaG90c3dhcE9ubHlWaXNpYmxlOiBob3Rzd2FwT25seVZpc2liaWxpdHksXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0Tm9uSG90c3dhcHBhYmxlUmVzb3VyY2UoXG4gIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLFxuICByZWFzb24/OiBzdHJpbmcsXG4pOiBDaGFuZ2VIb3Rzd2FwUmVzdWx0IHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgICAgcmVqZWN0ZWRDaGFuZ2VzOiBPYmplY3Qua2V5cyhjaGFuZ2UucHJvcGVydHlVcGRhdGVzKSxcbiAgICAgIGxvZ2ljYWxJZDogY2hhbmdlLmxvZ2ljYWxJZCxcbiAgICAgIHJlc291cmNlVHlwZTogY2hhbmdlLm5ld1ZhbHVlLlR5cGUsXG4gICAgICByZWFzb24sXG4gICAgfSxcbiAgXTtcbn1cbiJdfQ==