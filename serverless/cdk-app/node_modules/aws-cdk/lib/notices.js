"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachedDataSource = exports.WebsiteNoticeDataSource = exports.FilteredNotice = exports.Notices = exports.NoticesFilter = void 0;
const https = require("node:https");
const path = require("path");
const fs = require("fs-extra");
const semver = require("semver");
const awscli_compatible_1 = require("./api/aws-auth/awscli-compatible");
const logging_1 = require("./logging");
const error_1 = require("./toolkit/error");
const tree_1 = require("./tree");
const util_1 = require("./util");
const directories_1 = require("./util/directories");
const error_2 = require("./util/error");
const version_1 = require("./version");
const CACHE_FILE_PATH = path.join((0, directories_1.cdkCacheDir)(), 'notices.json');
class NoticesFilter {
    static filter(options) {
        return [
            ...this.findForCliVersion(options.data, options.cliVersion),
            ...this.findForFrameworkVersion(options.data, options.outDir),
            ...this.findForBootstrapVersion(options.data, options.bootstrappedEnvironments),
        ];
    }
    static findForCliVersion(data, cliVersion) {
        return (0, util_1.flatMap)(data, notice => {
            const affectedComponent = notice.components.find(component => component.name === 'cli');
            const affectedRange = affectedComponent?.version;
            if (affectedRange == null) {
                return [];
            }
            if (!semver.satisfies(cliVersion, affectedRange)) {
                return [];
            }
            return [new FilteredNotice(notice)];
        });
    }
    static findForFrameworkVersion(data, outDir) {
        const tree = (0, tree_1.loadTreeFromDir)(outDir);
        return (0, util_1.flatMap)(data, notice => {
            //  A match happens when:
            //
            //  1. The version of the node matches the version in the notice, interpreted
            //  as a semver range.
            //
            //  AND
            //
            //  2. The name in the notice is a prefix of the node name when the query ends in '.',
            //  or the two names are exactly the same, otherwise.
            const matched = (0, tree_1.some)(tree, node => {
                return this.resolveAliases(notice.components).some(component => compareNames(component.name, node.constructInfo?.fqn) &&
                    compareVersions(component.version, node.constructInfo?.version));
            });
            if (!matched) {
                return [];
            }
            return [new FilteredNotice(notice)];
            function compareNames(pattern, target) {
                if (target == null) {
                    return false;
                }
                return pattern.endsWith('.') ? target.startsWith(pattern) : pattern === target;
            }
            function compareVersions(pattern, target) {
                return semver.satisfies(target ?? '', pattern);
            }
        });
    }
    static findForBootstrapVersion(data, bootstrappedEnvironments) {
        return (0, util_1.flatMap)(data, notice => {
            const affectedComponent = notice.components.find(component => component.name === 'bootstrap');
            const affectedRange = affectedComponent?.version;
            if (affectedRange == null) {
                return [];
            }
            const affected = bootstrappedEnvironments.filter(i => {
                const semverBootstrapVersion = semver.coerce(i.bootstrapStackVersion);
                if (!semverBootstrapVersion) {
                    // we don't throw because notices should never crash the cli.
                    (0, logging_1.warning)(`While filtering notices, could not coerce bootstrap version '${i.bootstrapStackVersion}' into semver`);
                    return false;
                }
                return semver.satisfies(semverBootstrapVersion, affectedRange);
            });
            if (affected.length === 0) {
                return [];
            }
            const filtered = new FilteredNotice(notice);
            filtered.addDynamicValue('ENVIRONMENTS', affected.map(s => s.environment.name).join(','));
            return [filtered];
        });
    }
    static resolveAliases(components) {
        return (0, util_1.flatMap)(components, component => {
            if (component.name === 'framework') {
                return [{
                        name: '@aws-cdk/core.',
                        version: component.version,
                    }, {
                        name: 'aws-cdk-lib.',
                        version: component.version,
                    }];
            }
            else {
                return [component];
            }
        });
    }
}
exports.NoticesFilter = NoticesFilter;
/**
 * Provides access to notices the CLI can display.
 */
class Notices {
    /**
     * Create an instance. Note that this replaces the singleton.
     */
    static create(props) {
        this._instance = new Notices(props);
        return this._instance;
    }
    /**
     * Get the singleton instance. May return `undefined` if `create` has not been called.
     */
    static get() {
        return this._instance;
    }
    constructor(props) {
        this.data = new Set();
        // sets don't deduplicate interfaces, so we use a map.
        this.bootstrappedEnvironments = new Map();
        this.context = props.context;
        this.acknowledgedIssueNumbers = new Set(this.context.get('acknowledged-issue-numbers') ?? []);
        this.includeAcknowlegded = props.includeAcknowledged ?? false;
        this.output = props.output ?? 'cdk.out';
        this.shouldDisplay = props.shouldDisplay ?? true;
        this.httpOptions = props.httpOptions ?? {};
    }
    /**
     * Add a bootstrap information to filter on. Can have multiple values
     * in case of multi-environment deployments.
     */
    addBootstrappedEnvironment(bootstrapped) {
        const key = [
            bootstrapped.bootstrapStackVersion,
            bootstrapped.environment.account,
            bootstrapped.environment.region,
            bootstrapped.environment.name,
        ].join(':');
        this.bootstrappedEnvironments.set(key, bootstrapped);
    }
    /**
     * Refresh the list of notices this instance is aware of.
     * To make sure this never crashes the CLI process, all failures are caught and
     * slitently logged.
     *
     * If context is configured to not display notices, this will no-op.
     */
    async refresh(options = {}) {
        if (!this.shouldDisplay) {
            return;
        }
        try {
            const underlyingDataSource = options.dataSource ?? new WebsiteNoticeDataSource(this.httpOptions);
            const dataSource = new CachedDataSource(CACHE_FILE_PATH, underlyingDataSource, options.force ?? false);
            const notices = await dataSource.fetch();
            this.data = new Set(this.includeAcknowlegded ? notices : notices.filter(n => !this.acknowledgedIssueNumbers.has(n.issueNumber)));
        }
        catch (e) {
            (0, logging_1.debug)(`Could not refresh notices: ${e}`);
        }
    }
    /**
     * Display the relevant notices (unless context dictates we shouldn't).
     */
    display(options = {}) {
        if (!this.shouldDisplay) {
            return;
        }
        const filteredNotices = NoticesFilter.filter({
            data: Array.from(this.data),
            cliVersion: (0, version_1.versionNumber)(),
            outDir: this.output,
            bootstrappedEnvironments: Array.from(this.bootstrappedEnvironments.values()),
        });
        if (filteredNotices.length > 0) {
            (0, logging_1.info)('');
            (0, logging_1.info)('NOTICES         (What\'s this? https://github.com/aws/aws-cdk/wiki/CLI-Notices)');
            (0, logging_1.info)('');
            for (const filtered of filteredNotices) {
                const formatted = filtered.format();
                switch (filtered.notice.severity) {
                    case 'warning':
                        (0, logging_1.warning)(formatted);
                        break;
                    case 'error':
                        (0, logging_1.error)(formatted);
                        break;
                    default:
                        (0, logging_1.info)(formatted);
                }
                (0, logging_1.info)('');
            }
            (0, logging_1.info)(`If you donâ€™t want to see a notice anymore, use "cdk acknowledge <id>". For example, "cdk acknowledge ${filteredNotices[0].notice.issueNumber}".`);
        }
        if (options.showTotal ?? false) {
            (0, logging_1.info)('');
            (0, logging_1.info)(`There are ${filteredNotices.length} unacknowledged notice(s).`);
        }
    }
}
exports.Notices = Notices;
/**
 * Notice after passing the filter. A filter can augment a notice with
 * dynamic values as it has access to the dynamic matching data.
 */
class FilteredNotice {
    constructor(notice) {
        this.notice = notice;
        this.dynamicValues = {};
    }
    addDynamicValue(key, value) {
        this.dynamicValues[`{resolve:${key}}`] = value;
    }
    format() {
        const componentsValue = this.notice.components.map(c => `${c.name}: ${c.version}`).join(', ');
        return this.resolveDynamicValues([
            `${this.notice.issueNumber}\t${this.notice.title}`,
            this.formatOverview(),
            `\tAffected versions: ${componentsValue}`,
            `\tMore information at: https://github.com/aws/aws-cdk/issues/${this.notice.issueNumber}`,
        ].join('\n\n') + '\n');
    }
    formatOverview() {
        const wrap = (s) => s.replace(/(?![^\n]{1,60}$)([^\n]{1,60})\s/g, '$1\n');
        const heading = 'Overview: ';
        const separator = `\n\t${' '.repeat(heading.length)}`;
        const content = wrap(this.notice.overview)
            .split('\n')
            .join(separator);
        return '\t' + heading + content;
    }
    resolveDynamicValues(input) {
        const pattern = new RegExp(Object.keys(this.dynamicValues).join('|'), 'g');
        return input.replace(pattern, (matched) => this.dynamicValues[matched] ?? matched);
    }
}
exports.FilteredNotice = FilteredNotice;
class WebsiteNoticeDataSource {
    constructor(options = {}) {
        this.options = options;
    }
    fetch() {
        const timeout = 3000;
        return new Promise((resolve, reject) => {
            let req;
            let timer = setTimeout(() => {
                if (req) {
                    req.destroy(new error_1.ToolkitError('Request timed out'));
                }
            }, timeout);
            timer.unref();
            const options = {
                agent: awscli_compatible_1.AwsCliCompatible.proxyAgent(this.options),
            };
            try {
                req = https.get('https://cli.cdk.dev-tools.aws.dev/notices.json', options, res => {
                    if (res.statusCode === 200) {
                        res.setEncoding('utf8');
                        let rawData = '';
                        res.on('data', (chunk) => {
                            rawData += chunk;
                        });
                        res.on('end', () => {
                            try {
                                const data = JSON.parse(rawData).notices;
                                if (!data) {
                                    throw new error_1.ToolkitError("'notices' key is missing");
                                }
                                (0, logging_1.debug)('Notices refreshed');
                                resolve(data ?? []);
                            }
                            catch (e) {
                                reject(new error_1.ToolkitError(`Failed to parse notices: ${(0, error_2.formatErrorMessage)(e)}`));
                            }
                        });
                        res.on('error', e => {
                            reject(new error_1.ToolkitError(`Failed to fetch notices: ${(0, error_2.formatErrorMessage)(e)}`));
                        });
                    }
                    else {
                        reject(new error_1.ToolkitError(`Failed to fetch notices. Status code: ${res.statusCode}`));
                    }
                });
                req.on('error', reject);
            }
            catch (e) {
                reject(new error_1.ToolkitError(`HTTPS 'get' call threw an error: ${(0, error_2.formatErrorMessage)(e)}`));
            }
        });
    }
}
exports.WebsiteNoticeDataSource = WebsiteNoticeDataSource;
const TIME_TO_LIVE_SUCCESS = 60 * 60 * 1000; // 1 hour
const TIME_TO_LIVE_ERROR = 1 * 60 * 1000; // 1 minute
class CachedDataSource {
    constructor(fileName, dataSource, skipCache) {
        this.fileName = fileName;
        this.dataSource = dataSource;
        this.skipCache = skipCache;
    }
    async fetch() {
        const cachedData = await this.load();
        const data = cachedData.notices;
        const expiration = cachedData.expiration ?? 0;
        if (Date.now() > expiration || this.skipCache) {
            const freshData = await this.fetchInner();
            await this.save(freshData);
            return freshData.notices;
        }
        else {
            (0, logging_1.debug)(`Reading cached notices from ${this.fileName}`);
            return data;
        }
    }
    async fetchInner() {
        try {
            return {
                expiration: Date.now() + TIME_TO_LIVE_SUCCESS,
                notices: await this.dataSource.fetch(),
            };
        }
        catch (e) {
            (0, logging_1.debug)(`Could not refresh notices: ${e}`);
            return {
                expiration: Date.now() + TIME_TO_LIVE_ERROR,
                notices: [],
            };
        }
    }
    async load() {
        const defaultValue = {
            expiration: 0,
            notices: [],
        };
        try {
            return fs.existsSync(this.fileName)
                ? await fs.readJSON(this.fileName)
                : defaultValue;
        }
        catch (e) {
            (0, logging_1.debug)(`Failed to load notices from cache: ${e}`);
            return defaultValue;
        }
    }
    async save(cached) {
        try {
            await fs.writeJSON(this.fileName, cached);
        }
        catch (e) {
            (0, logging_1.debug)(`Failed to store notices in the cache: ${e}`);
        }
    }
}
exports.CachedDataSource = CachedDataSource;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90aWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm5vdGljZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsb0NBQW9DO0FBQ3BDLDZCQUE2QjtBQUU3QiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBRWpDLHdFQUFvRTtBQUNwRSx1Q0FBd0Q7QUFFeEQsMkNBQStDO0FBQy9DLGlDQUErQztBQUMvQyxpQ0FBaUM7QUFDakMsb0RBQWlEO0FBQ2pELHdDQUFrRDtBQUNsRCx1Q0FBMEM7QUFFMUMsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFBLHlCQUFXLEdBQUUsRUFBRSxjQUFjLENBQUMsQ0FBQztBQW9FakUsTUFBYSxhQUFhO0lBQ2pCLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBbUM7UUFDdEQsT0FBTztZQUNMLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLFVBQVUsQ0FBQztZQUMzRCxHQUFHLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUM7WUFDN0QsR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsd0JBQXdCLENBQUM7U0FDaEYsQ0FBQztJQUNKLENBQUM7SUFFTyxNQUFNLENBQUMsaUJBQWlCLENBQUMsSUFBYyxFQUFFLFVBQWtCO1FBQ2pFLE9BQU8sSUFBQSxjQUFPLEVBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFO1lBQzVCLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxLQUFLLEtBQUssQ0FBQyxDQUFDO1lBQ3hGLE1BQU0sYUFBYSxHQUFHLGlCQUFpQixFQUFFLE9BQU8sQ0FBQztZQUVqRCxJQUFJLGFBQWEsSUFBSSxJ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Q0FBa0I7Z0JBQ25ELENBQUMsQ0FBQyxZQUFZLENBQUM7UUFDbkIsQ0FBQztRQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7WUFDWCxJQUFBLGVBQUssRUFBQyxzQ0FBc0MsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNqRCxPQUFPLFlBQVksQ0FBQztRQUN0QixDQUFDO0lBQ0gsQ0FBQztJQUVPLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBcUI7UUFDdEMsSUFBSSxDQUFDO1lBQ0gsTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDNUMsQ0FBQztRQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7WUFDWCxJQUFBLGVBQUssRUFBQyx5Q0FBeUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN0RCxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBNURELDRDQTREQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENsaWVudFJlcXVlc3QgfSBmcm9tICdodHRwJztcbmltcG9ydCB7IFJlcXVlc3RPcHRpb25zIH0gZnJvbSAnaHR0cHMnO1xuaW1wb3J0ICogYXMgaHR0cHMgZnJvbSAnbm9kZTpodHRwcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHR5cGUgeyBFbnZpcm9ubWVudCB9IGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCB7IFNka0h0dHBPcHRpb25zIH0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHsgQXdzQ2xpQ29tcGF0aWJsZSB9IGZyb20gJy4vYXBpL2F3cy1hdXRoL2F3c2NsaS1jb21wYXRpYmxlJztcbmltcG9ydCB7IGRlYnVnLCBpbmZvLCB3YXJuaW5nLCBlcnJvciB9IGZyb20gJy4vbG9nZ2luZyc7XG5pbXBvcnQgeyBDb250ZXh0IH0gZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuL3Rvb2xraXQvZXJyb3InO1xuaW1wb3J0IHsgbG9hZFRyZWVGcm9tRGlyLCBzb21lIH0gZnJvbSAnLi90cmVlJztcbmltcG9ydCB7IGZsYXRNYXAgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgY2RrQ2FjaGVEaXIgfSBmcm9tICcuL3V0aWwvZGlyZWN0b3JpZXMnO1xuaW1wb3J0IHsgZm9ybWF0RXJyb3JNZXNzYWdlIH0gZnJvbSAnLi91dGlsL2Vycm9yJztcbmltcG9ydCB7IHZlcnNpb25OdW1iZXIgfSBmcm9tICcuL3ZlcnNpb24nO1xuXG5jb25zdCBDQUNIRV9GSUxFX1BBVEggPSBwYXRoLmpvaW4oY2RrQ2FjaGVEaXIoKSwgJ25vdGljZXMuanNvbicpO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGljZXNQcm9wcyB7XG4gIC8qKlxuICAgKiBDREsgY29udGV4dFxuICAgKi9cbiAgcmVhZG9ubHkgY29udGV4dDogQ29udGV4dDtcblxuICAvKipcbiAgICogSW5jbHVkZSBub3RpY2VzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYWNrbm93bGVkZ2VkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgaW5jbHVkZUFja25vd2xlZGdlZD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdsb2JhbCBDTEkgb3B0aW9uIGZvciBvdXRwdXQgZGlyZWN0b3J5IGZvciBzeW50aGVzaXplZCBjbG91ZCBhc3NlbWJseVxuICAgKlxuICAgKiBAZGVmYXVsdCAnY2RrLm91dCdcbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dD86IHN0cmluZztcblxuICAvKipcbiAgICogR2xvYmFsIENMSSBvcHRpb24gZm9yIHdoZXRoZXIgd2Ugc2hvdyBub3RpY2VzXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHNob3VsZERpc3BsYXk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciB0aGUgSFRUUCByZXF1ZXN0XG4gICAqL1xuICByZWFkb25seSBodHRwT3B0aW9ucz86IFNka0h0dHBPcHRpb25zO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGljZXNQcmludE9wdGlvbnMge1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGFwcGVuZCB0aGUgdG90YWwgbnVtYmVyIG9mIHVuYWNrbm93bGVkZ2VkIG5vdGljZXMgdG8gdGhlIGRpc3BsYXkuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBzaG93VG90YWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGljZXNSZWZyZXNoT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGZvcmNlIGEgY2FjaGUgcmVmcmVzaCByZWdhcmRsZXNzIG9mIGV4cGlyYXRpb24gdGltZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGZvcmNlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRGF0YSBzb3VyY2UgZm9yIGZldGNoIG5vdGljZXMgZnJvbS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBXZWJzaXRlTm90aWNlRGF0YVNvdXJjZVxuICAgKi9cbiAgcmVhZG9ubHkgZGF0YVNvdXJjZT86IE5vdGljZURhdGFTb3VyY2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWNlc0ZpbHRlckZpbHRlck9wdGlvbnMge1xuICByZWFkb25seSBkYXRhOiBOb3RpY2VbXTtcbiAgcmVhZG9ubHkgY2xpVmVyc2lvbjogc3RyaW5nO1xuICByZWFkb25seSBvdXREaXI6IHN0cmluZztcbiAgcmVhZG9ubHkgYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzOiBCb290c3RyYXBwZWRFbnZpcm9ubWVudFtdO1xufVxuXG5leHBvcnQgY2xhc3MgTm90aWNlc0ZpbHRlciB7XG4gIHB1YmxpYyBzdGF0aWMgZmlsdGVyKG9wdGlvbnM6IE5vdGljZXNGaWx0ZXJGaWx0ZXJPcHRpb25zKTogRmlsdGVyZWROb3RpY2VbXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLnRoaXMuZmluZEZvckNsaVZlcnNpb24ob3B0aW9ucy5kYXRhLCBvcHRpb25zLmNsaVZlcnNpb24pLFxuICAgICAgLi4udGhpcy5maW5kRm9yRnJhbWV3b3JrVmVyc2lvbihvcHRpb25zLmRhdGEsIG9wdGlvbnMub3V0RGlyKSxcbiAgICAgIC4uLnRoaXMuZmluZEZvckJvb3RzdHJhcFZlcnNpb24ob3B0aW9ucy5kYXRhLCBvcHRpb25zLmJvb3RzdHJhcHBlZEVudmlyb25tZW50cyksXG4gICAgXTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGZpbmRGb3JDbGlWZXJzaW9uKGRhdGE6IE5vdGljZVtdLCBjbGlWZXJzaW9uOiBzdHJpbmcpOiBGaWx0ZXJlZE5vdGljZVtdIHtcbiAgICByZXR1cm4gZmxhdE1hcChkYXRhLCBub3RpY2UgPT4ge1xuICAgICAgY29uc3QgYWZmZWN0ZWRDb21wb25lbnQgPSBub3RpY2UuY29tcG9uZW50cy5maW5kKGNvbXBvbmVudCA9PiBjb21wb25lbnQubmFtZSA9PT0gJ2NsaScpO1xuICAgICAgY29uc3QgYWZmZWN0ZWRSYW5nZSA9IGFmZmVjdGVkQ29tcG9uZW50Py52ZXJzaW9uO1xuXG4gICAgICBpZiAoYWZmZWN0ZWRSYW5nZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZW12ZXIuc2F0aXNmaWVzKGNsaVZlcnNpb24sIGFmZmVjdGVkUmFuZ2UpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtuZXcgRmlsdGVyZWROb3RpY2Uobm90aWNlKV07XG4gICAgfSk7XG5cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGZpbmRGb3JGcmFtZXdvcmtWZXJzaW9uKGRhdGE6IE5vdGljZVtdLCBvdXREaXI6IHN0cmluZyk6IEZpbHRlcmVkTm90aWNlW10ge1xuICAgIGNvbnN0IHRyZWUgPSBsb2FkVHJlZUZyb21EaXIob3V0RGlyKTtcbiAgICByZXR1cm4gZmxhdE1hcChkYXRhLCBub3RpY2UgPT4ge1xuXG4gICAgICAvLyAgQSBtYXRjaCBoYXBwZW5zIHdoZW46XG4gICAgICAvL1xuICAgICAgLy8gIDEuIFRoZSB2ZXJzaW9uIG9mIHRoZSBub2RlIG1hdGNoZXMgdGhlIHZlcnNpb24gaW4gdGhlIG5vdGljZSwgaW50ZXJwcmV0ZWRcbiAgICAgIC8vICBhcyBhIHNlbXZlciByYW5nZS5cbiAgICAgIC8vXG4gICAgICAvLyAgQU5EXG4gICAgICAvL1xuICAgICAgLy8gIDIuIFRoZSBuYW1lIGluIHRoZSBub3RpY2UgaXMgYSBwcmVmaXggb2YgdGhlIG5vZGUgbmFtZSB3aGVuIHRoZSBxdWVyeSBlbmRzIGluICcuJyxcbiAgICAgIC8vICBvciB0aGUgdHdvIG5hbWVzIGFyZSBleGFjdGx5IHRoZSBzYW1lLCBvdGhlcndpc2UuXG5cbiAgICAgIGNvbnN0IG1hdGNoZWQgPSBzb21lKHRyZWUsIG5vZGUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlQWxpYXNlcyhub3RpY2UuY29tcG9uZW50cykuc29tZShjb21wb25lbnQgPT5cbiAgICAgICAgICBjb21wYXJlTmFtZXMoY29tcG9uZW50Lm5hbWUsIG5vZGUuY29uc3RydWN0SW5mbz8uZnFuKSAmJlxuICAgICAgICAgIGNvbXBhcmVWZXJzaW9ucyhjb21wb25lbnQudmVyc2lvbiwgbm9kZS5jb25zdHJ1Y3RJbmZvPy52ZXJzaW9uKSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtuZXcgRmlsdGVyZWROb3RpY2Uobm90aWNlKV07XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmVOYW1lcyhwYXR0ZXJuOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uZW5kc1dpdGgoJy4nKSA/IHRhcmdldC5zdGFydHNXaXRoKHBhdHRlcm4pIDogcGF0dGVybiA9PT0gdGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb21wYXJlVmVyc2lvbnMocGF0dGVybjogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZyB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gc2VtdmVyLnNhdGlzZmllcyh0YXJnZXQgPz8gJycsIHBhdHRlcm4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZmluZEZvckJvb3RzdHJhcFZlcnNpb24oZGF0YTogTm90aWNlW10sIGJvb3RzdHJhcHBlZEVudmlyb25tZW50czogQm9vdHN0cmFwcGVkRW52aXJvbm1lbnRbXSk6IEZpbHRlcmVkTm90aWNlW10ge1xuICAgIHJldHVybiBmbGF0TWFwKGRhdGEsIG5vdGljZSA9PiB7XG4gICAgICBjb25zdCBhZmZlY3RlZENvbXBvbmVudCA9IG5vdGljZS5jb21wb25lbnRzLmZpbmQoY29tcG9uZW50ID0+IGNvbXBvbmVudC5uYW1lID09PSAnYm9vdHN0cmFwJyk7XG4gICAgICBjb25zdCBhZmZlY3RlZFJhbmdlID0gYWZmZWN0ZWRDb21wb25lbnQ/LnZlcnNpb247XG5cbiAgICAgIGlmIChhZmZlY3RlZFJhbmdlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhZmZlY3RlZCA9IGJvb3RzdHJhcHBlZEVudmlyb25tZW50cy5maWx0ZXIoaSA9PiB7XG5cbiAgICAgICAgY29uc3Qgc2VtdmVyQm9vdHN0cmFwVmVyc2lvbiA9IHNlbXZlci5jb2VyY2UoaS5ib290c3RyYXBTdGFja1ZlcnNpb24pO1xuICAgICAgICBpZiAoIXNlbXZlckJvb3RzdHJhcFZlcnNpb24pIHtcbiAgICAgICAgICAvLyB3ZSBkb24ndCB0aHJvdyBiZWNhdXNlIG5vdGljZXMgc2hvdWxkIG5ldmVyIGNyYXNoIHRoZSBjbGkuXG4gICAgICAgICAgd2FybmluZyhgV2hpbGUgZmlsdGVyaW5nIG5vdGljZXMsIGNvdWxkIG5vdCBjb2VyY2UgYm9vdHN0cmFwIHZlcnNpb24gJyR7aS5ib290c3RyYXBTdGFja1ZlcnNpb259JyBpbnRvIHNlbXZlcmApO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZW12ZXIuc2F0aXNmaWVzKHNlbXZlckJvb3RzdHJhcFZlcnNpb24sIGFmZmVjdGVkUmFuZ2UpO1xuXG4gICAgICB9KTtcblxuICAgICAgaWYgKGFmZmVjdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpbHRlcmVkID0gbmV3IEZpbHRlcmVkTm90aWNlKG5vdGljZSk7XG4gICAgICBmaWx0ZXJlZC5hZGREeW5hbWljVmFsdWUoJ0VOVklST05NRU5UUycsIGFmZmVjdGVkLm1hcChzID0+IHMuZW52aXJvbm1lbnQubmFtZSkuam9pbignLCcpKTtcblxuICAgICAgcmV0dXJuIFtmaWx0ZXJlZF07XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyByZXNvbHZlQWxpYXNlcyhjb21wb25lbnRzOiBDb21wb25lbnRbXSk6IENvbXBvbmVudFtdIHtcbiAgICByZXR1cm4gZmxhdE1hcChjb21wb25lbnRzLCBjb21wb25lbnQgPT4ge1xuICAgICAgaWYgKGNvbXBvbmVudC5uYW1lID09PSAnZnJhbWV3b3JrJykge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICBuYW1lOiAnQGF3cy1jZGsvY29yZS4nLFxuICAgICAgICAgIHZlcnNpb246IGNvbXBvbmVudC52ZXJzaW9uLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogJ2F3cy1jZGstbGliLicsXG4gICAgICAgICAgdmVyc2lvbjogY29tcG9uZW50LnZlcnNpb24sXG4gICAgICAgIH1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtjb21wb25lbnRdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgYSBib290c3RyYXBwZWQgZW52aXJvbm1lbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQm9vdHN0cmFwcGVkRW52aXJvbm1lbnQge1xuICByZWFkb25seSBib290c3RyYXBTdGFja1ZlcnNpb246IG51bWJlcjtcbiAgcmVhZG9ubHkgZW52aXJvbm1lbnQ6IEVudmlyb25tZW50O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byBub3RpY2VzIHRoZSBDTEkgY2FuIGRpc3BsYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RpY2VzIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZS4gTm90ZSB0aGF0IHRoaXMgcmVwbGFjZXMgdGhlIHNpbmdsZXRvbi5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlKHByb3BzOiBOb3RpY2VzUHJvcHMpOiBOb3RpY2VzIHtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG5ldyBOb3RpY2VzKHByb3BzKTtcbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaW5nbGV0b24gaW5zdGFuY2UuIE1heSByZXR1cm4gYHVuZGVmaW5lZGAgaWYgYGNyZWF0ZWAgaGFzIG5vdCBiZWVuIGNhbGxlZC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0KCk6IE5vdGljZXMgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIF9pbnN0YW5jZTogTm90aWNlcyB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIHJlYWRvbmx5IGNvbnRleHQ6IENvbnRleHQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgb3V0cHV0OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2hvdWxkRGlzcGxheTogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBhY2tub3dsZWRnZWRJc3N1ZU51bWJlcnM6IFNldDxOdW1iZXI+O1xuICBwcml2YXRlIHJlYWRvbmx5IGluY2x1ZGVBY2tub3dsZWdkZWQ6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgaHR0cE9wdGlvbnM6IFNka0h0dHBPcHRpb25zO1xuXG4gIHByaXZhdGUgZGF0YTogU2V0PE5vdGljZT4gPSBuZXcgU2V0KCk7XG5cbiAgLy8gc2V0cyBkb24ndCBkZWR1cGxpY2F0ZSBpbnRlcmZhY2VzLCBzbyB3ZSB1c2UgYSBtYXAuXG4gIHByaXZhdGUgcmVhZG9ubHkgYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzOiBNYXA8c3RyaW5nLCBCb290c3RyYXBwZWRFbnZpcm9ubWVudD4gPSBuZXcgTWFwKCk7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcm9wczogTm90aWNlc1Byb3BzKSB7XG4gICAgdGhpcy5jb250ZXh0ID0gcHJvcHMuY29udGV4dDtcbiAgICB0aGlzLmFja25vd2xlZGdlZElzc3VlTnVtYmVycyA9IG5ldyBTZXQodGhpcy5jb250ZXh0LmdldCgnYWNrbm93bGVkZ2VkLWlzc3VlLW51bWJlcnMnKSA/PyBbXSk7XG4gICAgdGhpcy5pbmNsdWRlQWNrbm93bGVnZGVkID0gcHJvcHMuaW5jbHVkZUFja25vd2xlZGdlZCA/PyBmYWxzZTtcbiAgICB0aGlzLm91dHB1dCA9IHByb3BzLm91dHB1dCA/PyAnY2RrLm91dCc7XG4gICAgdGhpcy5zaG91bGREaXNwbGF5ID0gcHJvcHMuc2hvdWxkRGlzcGxheSA/PyB0cnVlO1xuICAgIHRoaXMuaHR0cE9wdGlvbnMgPSBwcm9wcy5odHRwT3B0aW9ucyA/PyB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBib290c3RyYXAgaW5mb3JtYXRpb24gdG8gZmlsdGVyIG9uLiBDYW4gaGF2ZSBtdWx0aXBsZSB2YWx1ZXNcbiAgICogaW4gY2FzZSBvZiBtdWx0aS1lbnZpcm9ubWVudCBkZXBsb3ltZW50cy5cbiAgICovXG4gIHB1YmxpYyBhZGRCb290c3RyYXBwZWRFbnZpcm9ubWVudChib290c3RyYXBwZWQ6IEJvb3RzdHJhcHBlZEVudmlyb25tZW50KSB7XG4gICAgY29uc3Qga2V5ID0gW1xuICAgICAgYm9vdHN0cmFwcGVkLmJvb3RzdHJhcFN0YWNrVmVyc2lvbixcbiAgICAgIGJvb3RzdHJhcHBlZC5lbnZpcm9ubWVudC5hY2NvdW50LFxuICAgICAgYm9vdHN0cmFwcGVkLmVudmlyb25tZW50LnJlZ2lvbixcbiAgICAgIGJvb3RzdHJhcHBlZC5lbnZpcm9ubWVudC5uYW1lLFxuICAgIF0uam9pbignOicpO1xuICAgIHRoaXMuYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzLnNldChrZXksIGJvb3RzdHJhcHBlZCk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgbGlzdCBvZiBub3RpY2VzIHRoaXMgaW5zdGFuY2UgaXMgYXdhcmUgb2YuXG4gICAqIFRvIG1ha2Ugc3VyZSB0aGlzIG5ldmVyIGNyYXNoZXMgdGhlIENMSSBwcm9jZXNzLCBhbGwgZmFpbHVyZXMgYXJlIGNhdWdodCBhbmRcbiAgICogc2xpdGVudGx5IGxvZ2dlZC5cbiAgICpcbiAgICogSWYgY29udGV4dCBpcyBjb25maWd1cmVkIHRvIG5vdCBkaXNwbGF5IG5vdGljZXMsIHRoaXMgd2lsbCBuby1vcC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyByZWZyZXNoKG9wdGlvbnM6IE5vdGljZXNSZWZyZXNoT3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLnNob3VsZERpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdW5kZXJseWluZ0RhdGFTb3VyY2UgPSBvcHRpb25zLmRhdGFTb3VyY2UgPz8gbmV3IFdlYnNpdGVOb3RpY2VEYXRhU291cmNlKHRoaXMuaHR0cE9wdGlvbnMpO1xuICAgICAgY29uc3QgZGF0YVNvdXJjZSA9IG5ldyBDYWNoZWREYXRhU291cmNlKENBQ0hFX0ZJTEVfUEFUSCwgdW5kZXJseWluZ0RhdGFTb3VyY2UsIG9wdGlvbnMuZm9yY2UgPz8gZmFsc2UpO1xuICAgICAgY29uc3Qgbm90aWNlcyA9IGF3YWl0IGRhdGFTb3VyY2UuZmV0Y2goKTtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBTZXQodGhpcy5pbmNsdWRlQWNrbm93bGVnZGVkID8gbm90aWNlcyA6IG5vdGljZXMuZmlsdGVyKG4gPT4gIXRoaXMuYWNrbm93bGVkZ2VkSXNzdWVOdW1iZXJzLmhhcyhuLmlzc3VlTnVtYmVyKSkpO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgZGVidWcoYENvdWxkIG5vdCByZWZyZXNoIG5vdGljZXM6ICR7ZX1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGxheSB0aGUgcmVsZXZhbnQgbm90aWNlcyAodW5sZXNzIGNvbnRleHQgZGljdGF0ZXMgd2Ugc2hvdWxkbid0KS5cbiAgICovXG4gIHB1YmxpYyBkaXNwbGF5KG9wdGlvbnM6IE5vdGljZXNQcmludE9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5zaG91bGREaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyZWROb3RpY2VzID0gTm90aWNlc0ZpbHRlci5maWx0ZXIoe1xuICAgICAgZGF0YTogQXJyYXkuZnJvbSh0aGlzLmRhdGEpLFxuICAgICAgY2xpVmVyc2lvbjogdmVyc2lvbk51bWJlcigpLFxuICAgICAgb3V0RGlyOiB0aGlzLm91dHB1dCxcbiAgICAgIGJvb3RzdHJhcHBlZEVudmlyb25tZW50czogQXJyYXkuZnJvbSh0aGlzLmJvb3RzdHJhcHBlZEVudmlyb25tZW50cy52YWx1ZXMoKSksXG4gICAgfSk7XG5cbiAgICBpZiAoZmlsdGVyZWROb3RpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGluZm8oJycpO1xuICAgICAgaW5mbygnTk9USUNFUyAgICAgICAgIChXaGF0XFwncyB0aGlzPyBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvd2lraS9DTEktTm90aWNlcyknKTtcbiAgICAgIGluZm8oJycpO1xuICAgICAgZm9yIChjb25zdCBmaWx0ZXJlZCBvZiBmaWx0ZXJlZE5vdGljZXMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gZmlsdGVyZWQuZm9ybWF0KCk7XG4gICAgICAgIHN3aXRjaCAoZmlsdGVyZWQubm90aWNlLnNldmVyaXR5KSB7XG4gICAgICAgICAgY2FzZSAnd2FybmluZyc6XG4gICAgICAgICAgICB3YXJuaW5nKGZvcm1hdHRlZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICBlcnJvcihmb3JtYXR0ZWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGluZm8oZm9ybWF0dGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvKCcnKTtcbiAgICAgIH1cbiAgICAgIGluZm8oYElmIHlvdSBkb27igJl0IHdhbnQgdG8gc2VlIGEgbm90aWNlIGFueW1vcmUsIHVzZSBcImNkayBhY2tub3dsZWRnZSA8aWQ+XCIuIEZvciBleGFtcGxlLCBcImNkayBhY2tub3dsZWRnZSAke2ZpbHRlcmVkTm90aWNlc1swXS5ub3RpY2UuaXNzdWVOdW1iZXJ9XCIuYCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2hvd1RvdGFsID8/IGZhbHNlKSB7XG4gICAgICBpbmZvKCcnKTtcbiAgICAgIGluZm8oYFRoZXJlIGFyZSAke2ZpbHRlcmVkTm90aWNlcy5sZW5ndGh9IHVuYWNrbm93bGVkZ2VkIG5vdGljZShzKS5gKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnQge1xuICBuYW1lOiBzdHJpbmc7XG4gIHZlcnNpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3RpY2Uge1xuICB0aXRsZTogc3RyaW5nO1xuICBpc3N1ZU51bWJlcjogbnVtYmVyO1xuICBvdmVydmlldzogc3RyaW5nO1xuICBjb21wb25lbnRzOiBDb21wb25lbnRbXTtcbiAgc2NoZW1hVmVyc2lvbjogc3RyaW5nO1xuICBzZXZlcml0eT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBOb3RpY2UgYWZ0ZXIgcGFzc2luZyB0aGUgZmlsdGVyLiBBIGZpbHRlciBjYW4gYXVnbWVudCBhIG5vdGljZSB3aXRoXG4gKiBkeW5hbWljIHZhbHVlcyBhcyBpdCBoYXMgYWNjZXNzIHRvIHRoZSBkeW5hbWljIG1hdGNoaW5nIGRhdGEuXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJlZE5vdGljZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZHluYW1pY1ZhbHVlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgbm90aWNlOiBOb3RpY2UpIHt9XG5cbiAgcHVibGljIGFkZER5bmFtaWNWYWx1ZShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuZHluYW1pY1ZhbHVlc1tge3Jlc29sdmU6JHtrZXl9fWBdID0gdmFsdWU7XG4gIH1cblxuICBwdWJsaWMgZm9ybWF0KCk6IHN0cmluZyB7XG5cbiAgICBjb25zdCBjb21wb25lbnRzVmFsdWUgPSB0aGlzLm5vdGljZS5jb21wb25lbnRzLm1hcChjID0+IGAke2MubmFtZX06ICR7Yy52ZXJzaW9ufWApLmpvaW4oJywgJyk7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZUR5bmFtaWNWYWx1ZXMoW1xuICAgICAgYCR7dGhpcy5ub3RpY2UuaXNzdWVOdW1iZXJ9XFx0JHt0aGlzLm5vdGljZS50aXRsZX1gLFxuICAgICAgdGhpcy5mb3JtYXRPdmVydmlldygpLFxuICAgICAgYFxcdEFmZmVjdGVkIHZlcnNpb25zOiAke2NvbXBvbmVudHNWYWx1ZX1gLFxuICAgICAgYFxcdE1vcmUgaW5mb3JtYXRpb24gYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvJHt0aGlzLm5vdGljZS5pc3N1ZU51bWJlcn1gLFxuICAgIF0uam9pbignXFxuXFxuJykgKyAnXFxuJyk7XG4gIH1cblxuICBwcml2YXRlIGZvcm1hdE92ZXJ2aWV3KCkge1xuICAgIGNvbnN0IHdyYXAgPSAoczogc3RyaW5nKSA9PiBzLnJlcGxhY2UoLyg/IVteXFxuXXsxLDYwfSQpKFteXFxuXXsxLDYwfSlcXHMvZywgJyQxXFxuJyk7XG5cbiAgICBjb25zdCBoZWFkaW5nID0gJ092ZXJ2aWV3OiAnO1xuICAgIGNvbnN0IHNlcGFyYXRvciA9IGBcXG5cXHQkeycgJy5yZXBlYXQoaGVhZGluZy5sZW5ndGgpfWA7XG4gICAgY29uc3QgY29udGVudCA9IHdyYXAodGhpcy5ub3RpY2Uub3ZlcnZpZXcpXG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAuam9pbihzZXBhcmF0b3IpO1xuXG4gICAgcmV0dXJuICdcXHQnICsgaGVhZGluZyArIGNvbnRlbnQ7XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVEeW5hbWljVmFsdWVzKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKE9iamVjdC5rZXlzKHRoaXMuZHluYW1pY1ZhbHVlcykuam9pbignfCcpLCAnZycpO1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKHBhdHRlcm4sIChtYXRjaGVkKSA9PiB0aGlzLmR5bmFtaWNWYWx1ZXNbbWF0Y2hlZF0gPz8gbWF0Y2hlZCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3RpY2VEYXRhU291cmNlIHtcbiAgZmV0Y2goKTogUHJvbWlzZTxOb3RpY2VbXT47XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJzaXRlTm90aWNlRGF0YVNvdXJjZSBpbXBsZW1lbnRzIE5vdGljZURhdGFTb3VyY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IFNka0h0dHBPcHRpb25zO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFNka0h0dHBPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgZmV0Y2goKTogUHJvbWlzZTxOb3RpY2VbXT4ge1xuICAgIGNvbnN0IHRpbWVvdXQgPSAzMDAwO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgcmVxOiBDbGllbnRSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuXG4gICAgICBsZXQgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgIHJlcS5kZXN0cm95KG5ldyBUb29sa2l0RXJyb3IoJ1JlcXVlc3QgdGltZWQgb3V0JykpO1xuICAgICAgICB9XG4gICAgICB9LCB0aW1lb3V0KTtcblxuICAgICAgdGltZXIudW5yZWYoKTtcblxuICAgICAgY29uc3Qgb3B0aW9uczogUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIGFnZW50OiBBd3NDbGlDb21wYXRpYmxlLnByb3h5QWdlbnQodGhpcy5vcHRpb25zKSxcbiAgICAgIH07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcSA9IGh0dHBzLmdldCgnaHR0cHM6Ly9jbGkuY2RrLmRldi10b29scy5hd3MuZGV2L25vdGljZXMuanNvbicsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICByZXMgPT4ge1xuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgICAgICAgcmVzLnNldEVuY29kaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICAgIGxldCByYXdEYXRhID0gJyc7XG4gICAgICAgICAgICAgIHJlcy5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgIHJhd0RhdGEgKz0gY2h1bms7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UocmF3RGF0YSkubm90aWNlcyBhcyBOb3RpY2VbXTtcbiAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFwiJ25vdGljZXMnIGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGVidWcoJ05vdGljZXMgcmVmcmVzaGVkJyk7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEgPz8gW10pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb29sa2l0RXJyb3IoYEZhaWxlZCB0byBwYXJzZSBub3RpY2VzOiAke2Zvcm1hdEVycm9yTWVzc2FnZShlKX1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzLm9uKCdlcnJvcicsIGUgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9vbGtpdEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbm90aWNlczogJHtmb3JtYXRFcnJvck1lc3NhZ2UoZSl9YCkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgVG9vbGtpdEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbm90aWNlcy4gU3RhdHVzIGNvZGU6ICR7cmVzLnN0YXR1c0NvZGV9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICByZXEub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICByZWplY3QobmV3IFRvb2xraXRFcnJvcihgSFRUUFMgJ2dldCcgY2FsbCB0aHJldyBhbiBlcnJvcjogJHtmb3JtYXRFcnJvck1lc3NhZ2UoZSl9YCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmludGVyZmFjZSBDYWNoZWROb3RpY2VzIHtcbiAgZXhwaXJhdGlvbjogbnVtYmVyO1xuICBub3RpY2VzOiBOb3RpY2VbXTtcbn1cblxuY29uc3QgVElNRV9UT19MSVZFX1NVQ0NFU1MgPSA2MCAqIDYwICogMTAwMDsgLy8gMSBob3VyXG5jb25zdCBUSU1FX1RPX0xJVkVfRVJST1IgPSAxICogNjAgKiAxMDAwOyAvLyAxIG1pbnV0ZVxuXG5leHBvcnQgY2xhc3MgQ2FjaGVkRGF0YVNvdXJjZSBpbXBsZW1lbnRzIE5vdGljZURhdGFTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpbGVOYW1lOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBkYXRhU291cmNlOiBOb3RpY2VEYXRhU291cmNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2tpcENhY2hlPzogYm9vbGVhbikge1xuICB9XG5cbiAgYXN5bmMgZmV0Y2goKTogUHJvbWlzZTxOb3RpY2VbXT4ge1xuICAgIGNvbnN0IGNhY2hlZERhdGEgPSBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICBjb25zdCBkYXRhID0gY2FjaGVkRGF0YS5ub3RpY2VzO1xuICAgIGNvbnN0IGV4cGlyYXRpb24gPSBjYWNoZWREYXRhLmV4cGlyYXRpb24gPz8gMDtcblxuICAgIGlmIChEYXRlLm5vdygpID4gZXhwaXJhdGlvbiB8fCB0aGlzLnNraXBDYWNoZSkge1xuICAgICAgY29uc3QgZnJlc2hEYXRhID0gYXdhaXQgdGhpcy5mZXRjaElubmVyKCk7XG4gICAgICBhd2FpdCB0aGlzLnNhdmUoZnJlc2hEYXRhKTtcbiAgICAgIHJldHVybiBmcmVzaERhdGEubm90aWNlcztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoYFJlYWRpbmcgY2FjaGVkIG5vdGljZXMgZnJvbSAke3RoaXMuZmlsZU5hbWV9YCk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoSW5uZXIoKTogUHJvbWlzZTxDYWNoZWROb3RpY2VzPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cGlyYXRpb246IERhdGUubm93KCkgKyBUSU1FX1RPX0xJVkVfU1VDQ0VTUyxcbiAgICAgICAgbm90aWNlczogYXdhaXQgdGhpcy5kYXRhU291cmNlLmZldGNoKCksXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKGBDb3VsZCBub3QgcmVmcmVzaCBub3RpY2VzOiAke2V9YCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHBpcmF0aW9uOiBEYXRlLm5vdygpICsgVElNRV9UT19MSVZFX0VSUk9SLFxuICAgICAgICBub3RpY2VzOiBbXSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsb2FkKCk6IFByb21pc2U8Q2FjaGVkTm90aWNlcz4ge1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHtcbiAgICAgIGV4cGlyYXRpb246IDAsXG4gICAgICBub3RpY2VzOiBbXSxcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmcy5leGlzdHNTeW5jKHRoaXMuZmlsZU5hbWUpXG4gICAgICAgID8gYXdhaXQgZnMucmVhZEpTT04odGhpcy5maWxlTmFtZSkgYXMgQ2FjaGVkTm90aWNlc1xuICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZyhgRmFpbGVkIHRvIGxvYWQgbm90aWNlcyBmcm9tIGNhY2hlOiAke2V9YCk7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2F2ZShjYWNoZWQ6IENhY2hlZE5vdGljZXMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZnMud3JpdGVKU09OKHRoaXMuZmlsZU5hbWUsIGNhY2hlZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoYEZhaWxlZCB0byBzdG9yZSBub3RpY2VzIGluIHRoZSBjYWNoZTogJHtlfWApO1xuICAgIH1cbiAgfVxufVxuIl19