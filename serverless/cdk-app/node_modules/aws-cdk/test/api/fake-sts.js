"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FakeSts = void 0;
const client_sts_1 = require("@aws-sdk/client-sts");
const nock = require("nock");
const uuid = require("uuid");
const xmlJs = require("xml-js");
const error_1 = require("../../lib/util/error");
const mock_sdk_1 = require("../util/mock-sdk");
/**
 * Class for mocking AWS HTTP Requests and pretending to be STS
 *
 * This is necessary for testing our authentication layer. Most other mocking
 * libraries don't consider as they mock functional methods which happen BEFORE
 * the SDK's HTTP/Authentication layer.
 *
 * Instead, we want to validate how we're setting up credentials for the
 * SDK, so we pretend to be the STS server and have an in-memory database
 * of users and roles.
 *
 * With the v3 upgrade, this is only now half way being used as
 */
class FakeSts {
    constructor() {
        this.assumedRoles = new Array();
        this.identities = {};
        this.roles = {};
    }
    /**
     * Begin mocking
     */
    begin() {
        const self = this;
        nock.disableNetConnect();
        if (!nock.isActive()) {
            nock.activate();
        }
        nock(/.*/)
            .persist()
            .post(/.*/)
            .reply(function (uri, body, cb) {
            const parsedBody = typeof body === 'string' ? urldecode(body) : body;
            try {
                const response = self.handleRequest({
                    uri,
                    host: this.req.headers.host,
                    parsedBody,
                    headers: this.req.headers,
                });
                cb(null, [200, xmlJs.js2xml(response, { compact: true })]);
            }
            catch (e) {
                cb(null, [
                    400,
                    xmlJs.js2xml({
                        ErrorResponse: {
                            _attributes: { xmlns: 'https://sts.amazonaws.com/doc/2011-06-15/' },
                            Error: {
                                Type: 'Sender',
                                Code: e.name ?? 'Error',
                                Message: (0, error_1.formatErrorMessage)(e),
                            },
                            RequestId: '1',
                        },
                    }, { compact: true }),
                ]);
            }
        });
        // Scrub some environment variables that might be set if we're running on CodeBuild which will interfere with the tests.
        delete process.env.AWS_PROFILE;
        delete process.env.AWS_REGION;
        delete process.env.AWS_DEFAULT_REGION;
        delete process.env.AWS_ACCESS_KEY_ID;
        delete process.env.AWS_SECRET_ACCESS_KEY;
        delete process.env.AWS_SESSION_TOKEN;
    }
    /**
     * Restore everything to normal
     */
    restore() {
        nock.restore(); // https://github.com/nock/nock/issues/1817
        nock.cleanAll();
        nock.enableNetConnect();
    }
    /**
     * Register a user
     */
    registerUser(account, accessKey, options = {}) {
        const userName = options.name ?? `User${Object.keys(this.identities).length + 1}`;
        const arn = `arn:${options.partition ?? 'aws'}:sts::${account}:user/${userName}`;
        const userId = `${accessKey}:${userName}`;
        this.identities[accessKey] = {
            account,
            arn,
            userId,
        };
        this.setSTSMocks(account, arn, userName, accessKey);
    }
    /**
     * Register an assumable role
     */
    registerRole(account, roleArn, options = {}) {
        const roleName = options.name ?? `Role${Object.keys(this.roles).length + 1}`;
        this.roles[roleArn] = {
            allowedAccounts: options.allowedAccounts ?? [account],
            arn: roleArn,
            roleName,
            account,
        };
        this.setSTSMocks(account, roleArn, roleArn);
    }
    setSTSMocks(account, roleArn, name, accessKey) {
        const accessKeyId = accessKey ?? uuid.v4();
        mock_sdk_1.mockSTSClient
            .on(client_sts_1.GetCallerIdentityCommand)
            .resolves({
            Account: account,
            Arn: roleArn,
            UserId: name,
        })
            .on(client_sts_1.AssumeRoleCommand)
            .resolves({
            AssumedRoleUser: {
                Arn: roleArn,
                AssumedRoleId: `${accessKeyId}:${name}`,
            },
            Credentials: {
                AccessKeyId: accessKeyId,
                SecretAccessKey: 'Secret',
                SessionToken: 'Token',
                Expiration: new Date(Date.now() + 3600 * 1000),
            },
            PackedPolicySize: 6,
        });
    }
    handleRequest(mockRequest) {
        const response = (() => {
            const identity = this.identity(mockRequest);
            switch (mockRequest.parsedBody.Action) {
                case 'GetCallerIdentityCommand':
                    return this.handleGetCallerIdentity(identity);
                case 'AssumeRoleCommand':
                    return this.handleAssumeRole(identity, mockRequest);
            }
            throw new Error(`Unrecognized Action in MockAwsHttp: ${mockRequest.parsedBody.Action}`);
        })();
        return response;
    }
    handleGetCallerIdentity(identity) {
        return {
            GetCallerIdentityResponse: {
                _attributes: { xmlns: 'https://sts.amazonaws.com/doc/2011-06-15/' },
                GetCallerIdentityResult: {
                    Arn: identity.arn,
                    UserId: identity.userId,
                    Account: identity.account,
                },
                ResponseMetadata: {
                    RequestId: '1',
                },
            },
        };
    }
    /**
     * Maps have a funky encoding to them when sent to STS.
     *
     * @see https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html
     */
    decodeMapFromRequestBody(parameter, body) {
        return Object.entries(body)
            .filter(([key, _]) => key.startsWith(`${parameter}.member.`) && key.endsWith('.Key'))
            .map(([key, tagKey]) => ({
            Key: tagKey,
            Value: body[`${parameter}.member.${key.split('.')[2]}.Value`],
        }));
    }
    /**
     * Lists have a funky encoding when sent to STS.
     *
     * @see https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html
     */
    decodeListKeysFromRequestBody(parameter, body) {
        return Object.entries(body)
            .filter(([key]) => key.startsWith(`${parameter}.member.`))
            .map(([, value]) => value);
    }
    handleAssumeRole(identity, mockRequest) {
        this.checkForFailure(mockRequest.parsedBody.RoleArn);
        this.assumedRoles.push({
            roleArn: mockRequest.parsedBody.RoleArn,
            roleSessionName: mockRequest.parsedBody.RoleSessionName,
            serialNumber: mockRequest.parsedBody.SerialNumber,
            tokenCode: mockRequest.parsedBody.TokenCode,
            tags: this.decodeMapFromRequestBody('Tags', mockRequest.parsedBody),
            transitiveTagKeys: this.decodeListKeysFromRequestBody('TransitiveTagKeys', mockRequest.parsedBody),
        });
        const roleArn = mockRequest.parsedBody.RoleArn;
        const targetRole = this.roles[roleArn];
        if (!targetRole) {
            throw new Error(`No such role: ${roleArn}`);
        }
        if (!targetRole.allowedAccounts.includes(identity.account)) {
            throw new Error(`Identity from account: ${identity.account} not allowed to assume ${roleArn}, must be one of: ${targetRole.allowedAccounts}`);
        }
        const freshAccessKey = uuid.v4();
        // Register a new "user" (identity) for this access key
        this.registerUser(targetRole.account, freshAccessKey, {
            name: `AssumedRole-${targetRole.roleName}-${identity.userId}`,
        });
        return {
            AssumeRoleResponse: {
                _attributes: { xmlns: 'https://sts.amazonaws.com/doc/2011-06-15/' },
                AssumeRoleResult: {
                    AssumedRoleUser: {
                        Arn: roleArn,
                        AssumedRoleId: `${freshAccessKey}:${targetRole.roleName}`,
                    },
                    Credentials: {
                        AccessKeyId: freshAccessKey,
                        SecretAccessKey: 'Secret',
                        SessionToken: 'Token',
                        Expiration: new Date(Date.now() + 3600 * 1000).toISOString(),
                    },
                    PackedPolicySize: 6,
                },
            },
            ResponseMetadata: {
                RequestId: '1',
            },
        };
    }
    checkForFailure(s) {
        const failureRequested = s.match(/<FAIL:([^>]+)>/);
        if (failureRequested) {
            const err = new Error(`STS failing by user request: ${failureRequested[1]}`);
            err.name = failureRequested[1];
            throw err;
        }
    }
    identity(mockRequest) {
        const keyId = this.accessKeyId(mockRequest);
        this.checkForFailure(keyId);
        const ret = this.identities[keyId];
        if (!ret) {
            throw new Error(`Unrecognized access key used: ${keyId}`);
        }
        return ret;
    }
    /**
     * Return the access key from a signed request
     */
    accessKeyId(mockRequest) {
        // "AWS4-HMAC-SHA256 Credential=(ab1a5e4c-ff41-4811-ac5f-6d1230f7aa90)access/20201210/eu-bla-5/sts/aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date, Signature=9b31011173a7842fa372d4ef7c431c08f0b1514fdaf54145560a4db7ecd24529"
        const auth = mockRequest.headers.authorization;
        const m = auth?.match(/Credential=([^\/]+)/);
        if (!m) {
            throw new Error(`No correct authorization header: ${auth}`);
        }
        return m[1];
    }
}
exports.FakeSts = FakeSts;
function urldecode(body) {
    const parts = body.split('&');
    const ret = {};
    for (const part of parts) {
        const [k, v] = part.split('=');
        ret[decodeURIComponent(k)] = decodeURIComponent(v);
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFrZS1zdHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmYWtlLXN0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxvREFBdUY7QUFDdkYsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QixnQ0FBZ0M7QUFDaEMsZ0RBQTBEO0FBQzFELCtDQUFpRDtBQXdCakQ7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsTUFBYSxPQUFPO0lBTWxCO1FBTGdCLGlCQUFZLEdBQUcsSUFBSSxLQUFLLEVBQWUsQ0FBQztRQUVoRCxlQUFVLEdBQXVDLEVBQUUsQ0FBQztRQUNwRCxVQUFLLEdBQW1DLEVBQUUsQ0FBQztJQUVwQyxDQUFDO0lBRWhCOztPQUVHO0lBQ0ksS0FBSztRQUNWLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUVsQixJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUM7WUFDckIsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2xCLENBQUM7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1AsT0FBTyxFQUFFO2FBQ1QsSUFBSSxDQUFDLElBQUksQ0FBQzthQUNWLEtBQUssQ0FBQyxVQUFnQixHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUU7WUFDbEMsTUFBTSxVQUFVLEdBQUcsT0FBTyxJQUFJLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUVyRSxJQUFJLENBQUM7Z0JBQ0gsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztvQkFDbEMsR0FBRztvQkFDSCxJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSTtvQkFDM0IsVUFBVTtvQkFDVixPQUFPLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPO2lCQUMxQixDQUFDLENBQUM7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Q3ZDLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFLENBQUM7UUFDekIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQy9CLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3N1bWVSb2xlQ29tbWFuZCwgR2V0Q2FsbGVySWRlbnRpdHlDb21tYW5kLCBUYWcgfSBmcm9tICdAYXdzLXNkay9jbGllbnQtc3RzJztcbmltcG9ydCAqIGFzIG5vY2sgZnJvbSAnbm9jayc7XG5pbXBvcnQgKiBhcyB1dWlkIGZyb20gJ3V1aWQnO1xuaW1wb3J0ICogYXMgeG1sSnMgZnJvbSAneG1sLWpzJztcbmltcG9ydCB7IGZvcm1hdEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL2xpYi91dGlsL2Vycm9yJztcbmltcG9ydCB7IG1vY2tTVFNDbGllbnQgfSBmcm9tICcuLi91dGlsL21vY2stc2RrJztcblxuaW50ZXJmYWNlIFJlZ2lzdGVyZWRJZGVudGl0eSB7XG4gIHJlYWRvbmx5IGFjY291bnQ6IHN0cmluZztcbiAgcmVhZG9ubHkgYXJuOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHVzZXJJZDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVnaXN0ZXJlZFJvbGUge1xuICByZWFkb25seSBhY2NvdW50OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGFsbG93ZWRBY2NvdW50czogc3RyaW5nW107XG4gIHJlYWRvbmx5IGFybjogc3RyaW5nO1xuICByZWFkb25seSByb2xlTmFtZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQXNzdW1lZFJvbGUge1xuICByZWFkb25seSByb2xlQXJuOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHNlcmlhbE51bWJlcjogc3RyaW5nO1xuICByZWFkb25seSB0b2tlbkNvZGU6IHN0cmluZztcbiAgcmVhZG9ubHkgcm9sZVNlc3Npb25OYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHRhZ3M/OiBUYWdbXTtcbiAgcmVhZG9ubHkgdHJhbnNpdGl2ZVRhZ0tleXM/OiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBDbGFzcyBmb3IgbW9ja2luZyBBV1MgSFRUUCBSZXF1ZXN0cyBhbmQgcHJldGVuZGluZyB0byBiZSBTVFNcbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgdGVzdGluZyBvdXIgYXV0aGVudGljYXRpb24gbGF5ZXIuIE1vc3Qgb3RoZXIgbW9ja2luZ1xuICogbGlicmFyaWVzIGRvbid0IGNvbnNpZGVyIGFzIHRoZXkgbW9jayBmdW5jdGlvbmFsIG1ldGhvZHMgd2hpY2ggaGFwcGVuIEJFRk9SRVxuICogdGhlIFNESydzIEhUVFAvQXV0aGVudGljYXRpb24gbGF5ZXIuXG4gKlxuICogSW5zdGVhZCwgd2Ugd2FudCB0byB2YWxpZGF0ZSBob3cgd2UncmUgc2V0dGluZyB1cCBjcmVkZW50aWFscyBmb3IgdGhlXG4gKiBTREssIHNvIHdlIHByZXRlbmQgdG8gYmUgdGhlIFNUUyBzZXJ2ZXIgYW5kIGhhdmUgYW4gaW4tbWVtb3J5IGRhdGFiYXNlXG4gKiBvZiB1c2VycyBhbmQgcm9sZXMuXG4gKlxuICogV2l0aCB0aGUgdjMgdXBncmFkZSwgdGhpcyBpcyBvbmx5IG5vdyBoYWxmIHdheSBiZWluZyB1c2VkIGFzXG4gKi9cbmV4cG9ydCBjbGFzcyBGYWtlU3RzIHtcbiAgcHVibGljIHJlYWRvbmx5IGFzc3VtZWRSb2xlcyA9IG5ldyBBcnJheTxBc3N1bWVkUm9sZT4oKTtcblxuICBwcml2YXRlIGlkZW50aXRpZXM6IFJlY29yZDxzdHJpbmcsIFJlZ2lzdGVyZWRJZGVudGl0eT4gPSB7fTtcbiAgcHJpdmF0ZSByb2xlczogUmVjb3JkPHN0cmluZywgUmVnaXN0ZXJlZFJvbGU+ID0ge307XG5cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBCZWdpbiBtb2NraW5nXG4gICAqL1xuICBwdWJsaWMgYmVnaW4oKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBub2NrLmRpc2FibGVOZXRDb25uZWN0KCk7XG4gICAgaWYgKCFub2NrLmlzQWN0aXZlKCkpIHtcbiAgICAgIG5vY2suYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgbm9jaygvLiovKVxuICAgICAgLnBlcnNpc3QoKVxuICAgICAgLnBvc3QoLy4qLylcbiAgICAgIC5yZXBseShmdW5jdGlvbiAodGhpcywgdXJpLCBib2R5LCBjYikge1xuICAgICAgICBjb25zdCBwYXJzZWRCb2R5ID0gdHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnID8gdXJsZGVjb2RlKGJvZHkpIDogYm9keTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gc2VsZi5oYW5kbGVSZXF1ZXN0KHtcbiAgICAgICAgICAgIHVyaSxcbiAgICAgICAgICAgIGhvc3Q6IHRoaXMucmVxLmhlYWRlcnMuaG9zdCxcbiAgICAgICAgICAgIHBhcnNlZEJvZHksXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLnJlcS5oZWFkZXJzLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNiKG51bGwsIFsyMDAsIHhtbEpzLmpzMnhtbChyZXNwb25zZSwgeyBjb21wYWN0OiB0cnVlIH0pXSk7XG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgIGNiKG51bGwsIFtcbiAgICAgICAgICAgIDQwMCxcbiAgICAgICAgICAgIHhtbEpzLmpzMnhtbChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEVycm9yUmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgIF9hdHRyaWJ1dGVzOiB7IHhtbG5zOiAnaHR0cHM6Ly9zdHMuYW1hem9uYXdzLmNvbS9kb2MvMjAxMS0wNi0xNS8nIH0sXG4gICAgICAgICAgICAgICAgICBFcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICBUeXBlOiAnU2VuZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgQ29kZTogZS5uYW1lID8/ICdFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2U6IGZvcm1hdEVycm9yTWVzc2FnZShlKSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBSZXF1ZXN0SWQ6ICcxJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7IGNvbXBhY3Q6IHRydWUgfSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgLy8gU2NydWIgc29tZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCBtaWdodCBiZSBzZXQgaWYgd2UncmUgcnVubmluZyBvbiBDb2RlQnVpbGQgd2hpY2ggd2lsbCBpbnRlcmZlcmUgd2l0aCB0aGUgdGVzdHMuXG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkFXU19QUk9GSUxFO1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5BV1NfUkVHSU9OO1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9SRUdJT047XG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkFXU19BQ0NFU1NfS0VZX0lEO1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5BV1NfU0VDUkVUX0FDQ0VTU19LRVk7XG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkFXU19TRVNTSU9OX1RPS0VOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgZXZlcnl0aGluZyB0byBub3JtYWxcbiAgICovXG4gIHB1YmxpYyByZXN0b3JlKCkge1xuICAgIG5vY2sucmVzdG9yZSgpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9jay9ub2NrL2lzc3Vlcy8xODE3XG4gICAgbm9jay5jbGVhbkFsbCgpO1xuICAgIG5vY2suZW5hYmxlTmV0Q29ubmVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgdXNlclxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyVXNlcihhY2NvdW50OiBzdHJpbmcsIGFjY2Vzc0tleTogc3RyaW5nLCBvcHRpb25zOiBSZWdpc3RlclVzZXJPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB1c2VyTmFtZSA9IG9wdGlvbnMubmFtZSA/PyBgVXNlciR7T2JqZWN0LmtleXModGhpcy5pZGVudGl0aWVzKS5sZW5ndGggKyAxfWA7XG4gICAgY29uc3QgYXJuID0gYGFybjoke29wdGlvbnMucGFydGl0aW9uID8/ICdhd3MnfTpzdHM6OiR7YWNjb3VudH06dXNlci8ke3VzZXJOYW1lfWA7XG4gICAgY29uc3QgdXNlcklkID0gYCR7YWNjZXNzS2V5fToke3VzZXJOYW1lfWA7XG5cbiAgICB0aGlzLmlkZW50aXRpZXNbYWNjZXNzS2V5XSA9IHtcbiAgICAgIGFjY291bnQsXG4gICAgICBhcm4sXG4gICAgICB1c2VySWQsXG4gICAgfTtcblxuICAgIHRoaXMuc2V0U1RTTW9ja3MoYWNjb3VudCwgYXJuLCB1c2VyTmFtZSwgYWNjZXNzS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBhc3N1bWFibGUgcm9sZVxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyUm9sZShhY2NvdW50OiBzdHJpbmcsIHJvbGVBcm46IHN0cmluZywgb3B0aW9uczogUmVnaXN0ZXJSb2xlT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgcm9sZU5hbWUgPSBvcHRpb25zLm5hbWUgPz8gYFJvbGUke09iamVjdC5rZXlzKHRoaXMucm9sZXMpLmxlbmd0aCArIDF9YDtcblxuICAgIHRoaXMucm9sZXNbcm9sZUFybl0gPSB7XG4gICAgICBhbGxvd2VkQWNjb3VudHM6IG9wdGlvbnMuYWxsb3dlZEFjY291bnRzID8/IFthY2NvdW50XSxcbiAgICAgIGFybjogcm9sZUFybixcbiAgICAgIHJvbGVOYW1lLFxuICAgICAgYWNjb3VudCxcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRTVFNNb2NrcyhhY2NvdW50LCByb2xlQXJuLCByb2xlQXJuKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0U1RTTW9ja3MoYWNjb3VudDogc3RyaW5nLCByb2xlQXJuOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgYWNjZXNzS2V5Pzogc3RyaW5nKSB7XG4gICAgY29uc3QgYWNjZXNzS2V5SWQgPSBhY2Nlc3NLZXkgPz8gdXVpZC52NCgpO1xuICAgIG1vY2tTVFNDbGllbnRcbiAgICAgIC5vbihHZXRDYWxsZXJJZGVudGl0eUNvbW1hbmQpXG4gICAgICAucmVzb2x2ZXMoe1xuICAgICAgICBBY2NvdW50OiBhY2NvdW50LFxuICAgICAgICBBcm46IHJvbGVBcm4sXG4gICAgICAgIFVzZXJJZDogbmFtZSxcbiAgICAgIH0pXG4gICAgICAub24oQXNzdW1lUm9sZUNvbW1hbmQpXG4gICAgICAucmVzb2x2ZXMoe1xuICAgICAgICBBc3N1bWVkUm9sZVVzZXI6IHtcbiAgICAgICAgICBBcm46IHJvbGVBcm4sXG4gICAgICAgICAgQXNzdW1lZFJvbGVJZDogYCR7YWNjZXNzS2V5SWR9OiR7bmFtZX1gLFxuICAgICAgICB9LFxuICAgICAgICBDcmVkZW50aWFsczoge1xuICAgICAgICAgIEFjY2Vzc0tleUlkOiBhY2Nlc3NLZXlJZCxcbiAgICAgICAgICBTZWNyZXRBY2Nlc3NLZXk6ICdTZWNyZXQnLFxuICAgICAgICAgIFNlc3Npb25Ub2tlbjogJ1Rva2VuJyxcbiAgICAgICAgICBFeHBpcmF0aW9uOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgMzYwMCAqIDEwMDApLFxuICAgICAgICB9LFxuICAgICAgICBQYWNrZWRQb2xpY3lTaXplOiA2LFxuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVJlcXVlc3QobW9ja1JlcXVlc3Q6IE1vY2tSZXF1ZXN0KTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSAoKCkgPT4ge1xuICAgICAgY29uc3QgaWRlbnRpdHkgPSB0aGlzLmlkZW50aXR5KG1vY2tSZXF1ZXN0KTtcblxuICAgICAgc3dpdGNoIChtb2NrUmVxdWVzdC5wYXJzZWRCb2R5LkFjdGlvbikge1xuICAgICAgICBjYXNlICdHZXRDYWxsZXJJZGVudGl0eUNvbW1hbmQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUdldENhbGxlcklkZW50aXR5KGlkZW50aXR5KTtcblxuICAgICAgICBjYXNlICdBc3N1bWVSb2xlQ29tbWFuZCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQXNzdW1lUm9sZShpZGVudGl0eSwgbW9ja1JlcXVlc3QpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBBY3Rpb24gaW4gTW9ja0F3c0h0dHA6ICR7bW9ja1JlcXVlc3QucGFyc2VkQm9keS5BY3Rpb259YCk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUdldENhbGxlcklkZW50aXR5KGlkZW50aXR5OiBSZWdpc3RlcmVkSWRlbnRpdHkpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICByZXR1cm4ge1xuICAgICAgR2V0Q2FsbGVySWRlbnRpdHlSZXNwb25zZToge1xuICAgICAgICBfYXR0cmlidXRlczogeyB4bWxuczogJ2h0dHBzOi8vc3RzLmFtYXpvbmF3cy5jb20vZG9jLzIwMTEtMDYtMTUvJyB9LFxuICAgICAgICBHZXRDYWxsZXJJZGVudGl0eVJlc3VsdDoge1xuICAgICAgICAgIEFybjogaWRlbnRpdHkuYXJuLFxuICAgICAgICAgIFVzZXJJZDogaWRlbnRpdHkudXNlcklkLFxuICAgICAgICAgIEFjY291bnQ6IGlkZW50aXR5LmFjY291bnQsXG4gICAgICAgIH0sXG4gICAgICAgIFJlc3BvbnNlTWV0YWRhdGE6IHtcbiAgICAgICAgICBSZXF1ZXN0SWQ6ICcxJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXBzIGhhdmUgYSBmdW5reSBlbmNvZGluZyB0byB0aGVtIHdoZW4gc2VudCB0byBTVFMuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL1NUUy9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9Bc3N1bWVSb2xlLmh0bWxcbiAgICovXG4gIHByaXZhdGUgZGVjb2RlTWFwRnJvbVJlcXVlc3RCb2R5KHBhcmFtZXRlcjogc3RyaW5nLCBib2R5OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogVGFnW10ge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhib2R5KVxuICAgICAgLmZpbHRlcigoW2tleSwgX10pID0+IGtleS5zdGFydHNXaXRoKGAke3BhcmFtZXRlcn0ubWVtYmVyLmApICYmIGtleS5lbmRzV2l0aCgnLktleScpKVxuICAgICAgLm1hcCgoW2tleSwgdGFnS2V5XSkgPT4gKHtcbiAgICAgICAgS2V5OiB0YWdLZXksXG4gICAgICAgIFZhbHVlOiBib2R5W2Ake3BhcmFtZXRlcn0ubWVtYmVyLiR7a2V5LnNwbGl0KCcuJylbMl19LlZhbHVlYF0sXG4gICAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdHMgaGF2ZSBhIGZ1bmt5IGVuY29kaW5nIHdoZW4gc2VudCB0byBTVFMuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL1NUUy9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9Bc3N1bWVSb2xlLmh0bWxcbiAgICovXG4gIHByaXZhdGUgZGVjb2RlTGlzdEtleXNGcm9tUmVxdWVzdEJvZHkocGFyYW1ldGVyOiBzdHJpbmcsIGJvZHk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGJvZHkpXG4gICAgICAuZmlsdGVyKChba2V5XSkgPT4ga2V5LnN0YXJ0c1dpdGgoYCR7cGFyYW1ldGVyfS5tZW1iZXIuYCkpXG4gICAgICAubWFwKChbLCB2YWx1ZV0pID0+IHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQXNzdW1lUm9sZShpZGVudGl0eTogUmVnaXN0ZXJlZElkZW50aXR5LCBtb2NrUmVxdWVzdDogTW9ja1JlcXVlc3QpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICB0aGlzLmNoZWNrRm9yRmFpbHVyZShtb2NrUmVxdWVzdC5wYXJzZWRCb2R5LlJvbGVBcm4pO1xuXG4gICAgdGhpcy5hc3N1bWVkUm9sZXMucHVzaCh7XG4gICAgICByb2xlQXJuOiBtb2NrUmVxdWVzdC5wYXJzZWRCb2R5LlJvbGVBcm4sXG4gICAgICByb2xlU2Vzc2lvbk5hbWU6IG1vY2tSZXF1ZXN0LnBhcnNlZEJvZHkuUm9sZVNlc3Npb25OYW1lLFxuICAgICAgc2VyaWFsTnVtYmVyOiBtb2NrUmVxdWVzdC5wYXJzZWRCb2R5LlNlcmlhbE51bWJlcixcbiAgICAgIHRva2VuQ29kZTogbW9ja1JlcXVlc3QucGFyc2VkQm9keS5Ub2tlbkNvZGUsXG4gICAgICB0YWdzOiB0aGlzLmRlY29kZU1hcEZyb21SZXF1ZXN0Qm9keSgnVGFncycsIG1vY2tSZXF1ZXN0LnBhcnNlZEJvZHkpLFxuICAgICAgdHJhbnNpdGl2ZVRhZ0tleXM6IHRoaXMuZGVjb2RlTGlzdEtleXNGcm9tUmVxdWVzdEJvZHkoJ1RyYW5zaXRpdmVUYWdLZXlzJywgbW9ja1JlcXVlc3QucGFyc2VkQm9keSksXG4gICAgfSk7XG5cbiAgICBjb25zdCByb2xlQXJuID0gbW9ja1JlcXVlc3QucGFyc2VkQm9keS5Sb2xlQXJuO1xuICAgIGNvbnN0IHRhcmdldFJvbGUgPSB0aGlzLnJvbGVzW3JvbGVBcm5dO1xuICAgIGlmICghdGFyZ2V0Um9sZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdWNoIHJvbGU6ICR7cm9sZUFybn1gKTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldFJvbGUuYWxsb3dlZEFjY291bnRzLmluY2x1ZGVzKGlkZW50aXR5LmFjY291bnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJZGVudGl0eSBmcm9tIGFjY291bnQ6ICR7aWRlbnRpdHkuYWNjb3VudH0gbm90IGFsbG93ZWQgdG8gYXNzdW1lICR7cm9sZUFybn0sIG11c3QgYmUgb25lIG9mOiAke3RhcmdldFJvbGUuYWxsb3dlZEFjY291bnRzfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGZyZXNoQWNjZXNzS2V5ID0gdXVpZC52NCgpO1xuXG4gICAgLy8gUmVnaXN0ZXIgYSBuZXcgXCJ1c2VyXCIgKGlkZW50aXR5KSBmb3IgdGhpcyBhY2Nlc3Mga2V5XG4gICAgdGhpcy5yZWdpc3RlclVzZXIodGFyZ2V0Um9sZS5hY2NvdW50LCBmcmVzaEFjY2Vzc0tleSwge1xuICAgICAgbmFtZTogYEFzc3VtZWRSb2xlLSR7dGFyZ2V0Um9sZS5yb2xlTmFtZX0tJHtpZGVudGl0eS51c2VySWR9YCxcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBBc3N1bWVSb2xlUmVzcG9uc2U6IHtcbiAgICAgICAgX2F0dHJpYnV0ZXM6IHsgeG1sbnM6ICdodHRwczovL3N0cy5hbWF6b25hd3MuY29tL2RvYy8yMDExLTA2LTE1LycgfSxcbiAgICAgICAgQXNzdW1lUm9sZVJlc3VsdDoge1xuICAgICAgICAgIEFzc3VtZWRSb2xlVXNlcjoge1xuICAgICAgICAgICAgQXJuOiByb2xlQXJuLFxuICAgICAgICAgICAgQXNzdW1lZFJvbGVJZDogYCR7ZnJlc2hBY2Nlc3NLZXl9OiR7dGFyZ2V0Um9sZS5yb2xlTmFtZX1gLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgQ3JlZGVudGlhbHM6IHtcbiAgICAgICAgICAgIEFjY2Vzc0tleUlkOiBmcmVzaEFjY2Vzc0tleSxcbiAgICAgICAgICAgIFNlY3JldEFjY2Vzc0tleTogJ1NlY3JldCcsXG4gICAgICAgICAgICBTZXNzaW9uVG9rZW46ICdUb2tlbicsXG4gICAgICAgICAgICBFeHBpcmF0aW9uOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgMzYwMCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBQYWNrZWRQb2xpY3lTaXplOiA2LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIFJlc3BvbnNlTWV0YWRhdGE6IHtcbiAgICAgICAgUmVxdWVzdElkOiAnMScsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGNoZWNrRm9yRmFpbHVyZShzOiBzdHJpbmcpIHtcbiAgICBjb25zdCBmYWlsdXJlUmVxdWVzdGVkID0gcy5tYXRjaCgvPEZBSUw6KFtePl0rKT4vKTtcbiAgICBpZiAoZmFpbHVyZVJlcXVlc3RlZCkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBTVFMgZmFpbGluZyBieSB1c2VyIHJlcXVlc3Q6ICR7ZmFpbHVyZVJlcXVlc3RlZFsxXX1gKTtcbiAgICAgIChlcnIgYXMgYW55KS5uYW1lID0gZmFpbHVyZVJlcXVlc3RlZFsxXTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlkZW50aXR5KG1vY2tSZXF1ZXN0OiBNb2NrUmVxdWVzdCkge1xuICAgIGNvbnN0IGtleUlkID0gdGhpcy5hY2Nlc3NLZXlJZChtb2NrUmVxdWVzdCk7XG4gICAgdGhpcy5jaGVja0ZvckZhaWx1cmUoa2V5SWQpO1xuXG4gICAgY29uc3QgcmV0ID0gdGhpcy5pZGVudGl0aWVzW2tleUlkXTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgYWNjZXNzIGtleSB1c2VkOiAke2tleUlkfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYWNjZXNzIGtleSBmcm9tIGEgc2lnbmVkIHJlcXVlc3RcbiAgICovXG4gIHByaXZhdGUgYWNjZXNzS2V5SWQobW9ja1JlcXVlc3Q6IE1vY2tSZXF1ZXN0KTogc3RyaW5nIHtcbiAgICAvLyBcIkFXUzQtSE1BQy1TSEEyNTYgQ3JlZGVudGlhbD0oYWIxYTVlNGMtZmY0MS00ODExLWFjNWYtNmQxMjMwZjdhYTkwKWFjY2Vzcy8yMDIwMTIxMC9ldS1ibGEtNS9zdHMvYXdzNF9yZXF1ZXN0LCBTaWduZWRIZWFkZXJzPWhvc3Q7eC1hbXotY29udGVudC1zaGEyNTY7eC1hbXotZGF0ZSwgU2lnbmF0dXJlPTliMzEwMTExNzNhNzg0MmZhMzcyZDRlZjdjNDMxYzA4ZjBiMTUxNGZkYWY1NDE0NTU2MGE0ZGI3ZWNkMjQ1MjlcIlxuICAgIGNvbnN0IGF1dGggPSBtb2NrUmVxdWVzdC5oZWFkZXJzLmF1dGhvcml6YXRpb247XG5cbiAgICBjb25zdCBtID0gYXV0aD8ubWF0Y2goL0NyZWRlbnRpYWw9KFteXFwvXSspLyk7XG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvcnJlY3QgYXV0aG9yaXphdGlvbiBoZWFkZXI6ICR7YXV0aH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1bMV07XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWdpc3RlclVzZXJPcHRpb25zIHtcbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcbiAgcmVhZG9ubHkgcGFydGl0aW9uPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlZ2lzdGVyUm9sZU9wdGlvbnMge1xuICByZWFkb25seSBhbGxvd2VkQWNjb3VudHM/OiBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTVFNNb2Nrc09wdGlvbnMge1xuICByZWFkb25seSBhY2Nlc3NLZXk/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBNb2NrUmVxdWVzdCB7XG4gIHJlYWRvbmx5IGhvc3Q6IHN0cmluZztcbiAgcmVhZG9ubHkgdXJpOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHJlYWRvbmx5IHBhcnNlZEJvZHk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHJlYWRvbmx5IHNlc3Npb25UYWdzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbn1cblxuZnVuY3Rpb24gdXJsZGVjb2RlKGJvZHk6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICBjb25zdCBwYXJ0cyA9IGJvZHkuc3BsaXQoJyYnKTtcbiAgY29uc3QgcmV0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGNvbnN0IFtrLCB2XSA9IHBhcnQuc3BsaXQoJz0nKTtcbiAgICByZXRbZGVjb2RlVVJJQ29tcG9uZW50KGspXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIl19